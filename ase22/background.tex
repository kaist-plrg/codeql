\section{Background}\label{sec:background} 

\begin{figure}[t]
  \centering
  \vspace{2mm}
  \includegraphics[width=0.47\textwidth]{img/ov1.png}
%  \vspace*{-1.5em}
  \caption{Process of a declarative style analysis}
  \label{fig:ov1}
%\vspace*{-.5em}
\end{figure}

Figure~\ref{fig:ov1} presents the overview of how a declarative style analysis
works.  The analysis consists of three steps.  First, a given program gets
converted into database of syntactic facts.  Second, the rules that generate
new facts are defined, and a declarative language engine evaluates the rules
with the given facts, producing new facts.  Finally, the query is executed to
extract all the facts that meet certain conditions, which correspond to the
analysis result.

\textbf{Step 1: Extracting syntactic facts.}
The first step is to extract syntactic facts from a given source code.
Syntactic facts include facts about certain AST nodes and
the parent-child relationship between nodes. For example, consider
the following code:

\begin{lstlisting}[style=cpp,xleftmargin=2.5em]
function f() {
  return 42;
}
\end{lstlisting}
We can define a syntactic fact of the form {\tt FunctionAt(ln, name)},
where {\tt ln} denotes the line number and {\tt name}
denotes a name of the function defined at line {\tt ln}.
Therefore, we can extract the fact {\tt FunctionAt(1, "f")}.
Another example syntactic fact is {\tt EnclosingStmt(ln1, ln2, i)},
which denotes that the function at line {\tt ln1} has the statement
at line {\tt ln2} as the {\tt i}-th subexpression.
For example, we can extract the following syntactic facts:
{\tt EnclosingStmt(1, 2, 0)}.

In a sense, these syntactic facts serve as building blocks for the
common Intermediate Representation (IR) of multiple languages.
Compared to other IRs, this declarative-style IR has a few advantages.
First, extracting information from source code in this format does not
require any consideration of the language semantics, which imposes
almost no performance overhead beyond parsing the source code.
Second, the syntactic facts can be utilized easily in any other kind of
analysis, since they are simple information that can be freely
manipulated by defining new rules. Therefore, even when we use a different
client analysis, we can reuse the extracted syntactic facts
without re-extracting them from the source code.

\textbf{Step 2: Defining rules.}
The next step is to define rules to generate new facts out of known facts.
%This step corresponds to actually implementing the algorithm of a
%static analysis in a declarative style.
For example, recall that we can define a call graph
{\tt CallEdge(l1, l2)} using the facts
named {\tt FunctionAt} and {\tt CallAt}.
The defined rules are evaluated with declarative engines to finding all possible
facts that can be derived. The rules are usually evaluated in a bottom-up
and modular manner. Each rule is evaluated one-by-one, after every
rule it depends on is evaluated. 

\textbf{Step 3: Performing queries.}
The final step is to perform queries via query system.
The result of the query corresponds to actual result of client analysis.
A query consists of set of facts, where some of the facts would have
varaibles as arguments. Given a query, the query sytem will find all possible
assignment on variables, that will make every facts would hold under
the assignment.

\section{Overview}
In this section, we show an overview of how declarative style analysis
targetting multiple languages is performed with example of call graph
construction as a client analysis,
and demonstrate our approach to extend the analyzer to support analysis
across languages.

\begin{figure}[t]
  \centering
  \vspace{2mm}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=java,xleftmargin=2.5em]
import f

def m1():
    f()
def m2():
    pass

m1()
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{Method in language A calling a function in language B}
    \label{fig:exam:langA}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=cpp,firstnumber=5,xleftmargin=2.5em]
void f() {
    CallMethod("m2");
}
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{Function in language B}
    \label{fig:exam:langB}
  \end{subfigure}
  \vspace*{-.5em}
  \caption{Multilingual code in language A and language B}
  \label{fig:exam}
\end{figure}

Let us consider a hypothetical multilingual program written in a Python-like language A
and a C-like language B.

The program in Figure~\ref{fig:exam} has two parts: Figure~\ref{fig:exam}(a)
shows a method \javacode{m1}, \javacode{m2} in language A, and
Figure~\ref{fig:exam}(b) shows a function \ccode{f} in language B.  The method
\javacode{m1} is called from top level of language A, and it calls the the function \ccode{f}
from language B.  Then, the function \ccode{f} calls back the method \javacode{m2} in language A
using API function, using the string value \"m2\" to indicate the name of method.

\subsection{Analyses of single-language programs}
FIrst, let\'s look at how the analysis for language A can be done.
As a first step, the database of facts are created from the source code. THe
facts created in this way may contain some syntactic information about the
source code. For example, we can think of two kinds of facts: MethodAt(l, name) which
indicates that the method name 'name' is defined at line number l,
and CallAt(l, name), which indicates there is a call to a method named 'name' at line l.
Specifically, the program at Figure~\ref{fig:exam}(a) would be transformed into
the following facts:

MethodAt(2, m1)
MethodAt(3, m2)
CallAt(7, m1)

Next, there are rules that derice new facts from the known facts.
In this example, we would want to define the rule for generating the facts of
CallEdge(l1, l2), which indicates there is an call edge from the call expression at line l1
to the method definition at line l2. Using the know facts of MethodAt and CallAt,
we can define the rule like folowing:

CallEdge(l1, l2) :-
    CallAt(l1, call\_name),
    MethodAt(l2, meth\_name),
    call\_name = meth\_name.

The meaning of this rule is straight forward. Whenever there is a method definition
and a method call with the sane name, then there is c call edge between them.
By applying this rule on top of facts obtained above, we would
get this new fact:

CallEdge(7, 2).

Finally, there is a query system that is used for extracting certain sets of facts
that meet certain condition. For example, we can simply make a query to find every calledge
using following query:

?- CallEdge(X, Y).

which should output the result of X=7 and Y=2.



\subsection{Analysis of multilingual program}
1. create db -> by simply merging two

2. rules -> intra: same, inter: new

3. Query system -> exactly same as before, but now reports more call edge

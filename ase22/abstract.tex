\begin{abstract}
Declarative static program analysis has become one of the widely-used
program analysis techniques thanks to its logical specification:
it specifies ``what'' rather than ``how.''
Declarative static analyzers perform three steps: creating a database of facts from
program source code, evaluating rules to generate new facts, and running queries
over facts to extract all information related to specific properties via
a query system.
Declarative static analyzers can easily support diverse programming languages
as their analysis targets by extending only databases and rules
for new languages. Because the query system is independent of
programming languages, it can be reusable. However, even though they support multiple
programming languages, they do not support analysis of multilingual
programs written in two or more programming languages.
With the growing use of multilingual programs in diverse areas,
supporting multilingual program analysis is increasingly important.


In this paper, we propose a systematic methodology that extends a
declarative static analyzer supporting multiple target languages to support
multilingual program analysis as well. The main idea is to reuse
existing components of the analyzer to minimize the burden of creating new
components.  Our approach first generates a merged database
of facts, which consists of multiple logical language spaces so that
existing language-specific rules derive new facts for the corresponding language
from the facts in the corresponding language space. Then, it defines
language-interoperation rules that take the language  interoperation semantics into account.
Finally, it uses the same query system to get analysis results
leveraging the language interoperation semantics.
We develop a proof-of-concept declarative static analyzer for
multilingual programs by extending CodeQL, which can track data-flows
across language boundaries. The analyzer can analyze two types of multilingual programs:
JNI programs written in Java and C, and Python-C programs 
written in Python and C.  We also implement a bug checker on top of
the analyzer to detect data-flow related interoperation bugs in rea- world JNI programs.
Our evaluation shows that the analyzer successfully tracks
data-flows across Java-C and Python-C language boundaries and detects genuine
interoperation bugs in real-world multilingual programs.
\end{abstract}

/**
 * An invocation of the compiler. Note that more than one file may be
 * compiled per invocation. For example, this command compiles three
 * source files:
 *
 *   javac A.java B.java C.java
 *
 * The `id` simply identifies the invocation, while `cwd` is the working
 * directory from which the compiler was invoked.
 */
java_compilations(
    /**
     * An invocation of the compiler. Note that more than one file may
     * be compiled per invocation. For example, this command compiles
     * three source files:
     *
     *   javac A.java B.java C.java
     */
    unique int id : @java_compilation,
    string cwd : string ref
);

/**
 * The arguments that were passed to the extractor for a compiler
 * invocation. If `id` is for the compiler invocation
 *
 *   javac A.java B.java C.java
 *
 * then typically there will be rows for
 *
 * num | arg
 * --- | ---
 * 0   | *path to extractor*
 * 1   | `--javac-args`
 * 2   | A.java
 * 3   | B.java
 * 4   | C.java
 */
#keyset[id, num]
java_compilation_args(
    int id : @java_compilation ref,
    int num : int ref,
    string arg : string ref
);

/**
 * The source files that are compiled by a compiler invocation.
 * If `id` is for the compiler invocation
 *
 *   javac A.java B.java C.java
 *
 * then there will be rows for
 *
 * num | arg
 * --- | ---
 * 0   | A.java
 * 1   | B.java
 * 2   | C.java
 */
#keyset[id, num]
java_compilation_compiling_files(
    int id : @java_compilation ref,
    int num : int ref,
    int file : @java_file ref
);

/**
 * The time taken by the extractor for a compiler invocation.
 *
 * For each file `num`, there will be rows for
 *
 * kind | seconds
 * ---- | ---
 * 1    | CPU seconds used by the extractor frontend
 * 2    | Elapsed seconds during the extractor frontend
 * 3    | CPU seconds used by the extractor backend
 * 4    | Elapsed seconds during the extractor backend
 */
#keyset[id, num, kind]
java_compilation_time(
    int id : @java_compilation ref,
    int num : int ref,
    /* kind:
       1 = frontend_cpu_seconds
       2 = frontend_elapsed_seconds
       3 = extractor_cpu_seconds
       4 = extractor_elapsed_seconds
    */
    int kind : int ref,
    float seconds : float ref
);

/**
 * An error or warning generated by the extractor.
 * The diagnostic message `diagnostic` was generated during compiler
 * invocation `compilation`, and is the `file_number_diagnostic_number`th
 * message generated while extracting the `file_number`th file of that
 * invocation.
 */
#keyset[compilation, file_number, file_number_diagnostic_number]
java_diagnostic_for(
    unique int diagnostic : @java_diagnostic ref,
    int compilation : @java_compilation ref,
    int file_number : int ref,
    int file_number_diagnostic_number : int ref
);

/**
 * If extraction was successful, then `cpu_seconds` and
 * `elapsed_seconds` are the CPU time and elapsed time (respectively)
 * that extraction took for compiler invocation `id`.
 */
java_compilation_finished(
    unique int id : @java_compilation ref,
    float cpu_seconds : float ref,
    float elapsed_seconds : float ref
);

java_diagnostics(
    unique int id: @java_diagnostic,
    int severity: int ref,
    string error_tag: string ref,
    string error_message: string ref,
    string full_error_message: string ref,
    int location: @java_location_default ref
);

/*
 * External artifacts
 */

java_externalData(
  int id : @java_externalDataElement,
  string path : string ref,
  int column: int ref,
  string value : string ref
);

java_snapshotDate(
  unique date snapshotDate : date ref
);

sourceLocationPrefix(
  string prefix : string ref
);

/*
 * Duplicate code
 */

java_duplicateCode(
  unique int id : @java_duplication,
  string relativePath : string ref,
  int equivClass : int ref
);

java_similarCode(
  unique int id : @java_similarity,
  string relativePath : string ref,
  int equivClass : int ref
);

@java_duplication_or_similarity = @java_duplication | @java_similarity

java_tokens(
  int id : @java_duplication_or_similarity ref,
  int offset : int ref,
  int beginLine : int ref,
  int beginColumn : int ref,
  int endLine : int ref,
  int endColumn : int ref
);

/*
 * SMAP
 */

java_smap_header(
  int outputFileId: @java_file ref,
  string outputFilename: string ref,
  string defaultStratum: string ref
);

java_smap_files(
  int outputFileId: @java_file ref,
  string stratum: string ref,
  int inputFileNum: int ref,
  string inputFileName: string ref,
  int inputFileId: @java_file ref
);

java_smap_lines(
  int outputFileId: @java_file ref,
  string stratum: string ref,
  int inputFileNum: int ref,
  int inputStartLine: int ref,
  int inputLineCount: int ref,
  int outputStartLine: int ref,
  int outputLineIncrement: int ref
);

/*
 * Locations and files
 */

@java_location = @java_location_default ;

java_locations_default(
  unique int id: @java_location_default,
  int file: @java_file ref,
  int beginLine: int ref,
  int beginColumn: int ref,
  int endLine: int ref,
  int endColumn: int ref
);

java_hasLocation(
  int locatableid: @java_locatable ref,
  int id: @java_location ref
);

@java_sourceline = @java_locatable ;

#keyset[element_id]
java_numlines(
  int element_id: @java_sourceline ref,
  int num_lines: int ref,
  int num_code: int ref,
  int num_comment: int ref
);

java_files(
  unique int id: @java_file,
  string name: string ref,
  string simple: string ref,
  string ext: string ref,
  int fromSource: int ref // deprecated
);

java_folders(
  unique int id: @java_folder,
  string name: string ref,
  string simple: string ref
);

@java_container = @java_folder | @java_file

java_containerparent(
  int parent: @java_container ref,
  unique int child: @java_container ref
);

/*
 * Java
 */

java_cupackage(
  unique int id: @java_file ref,
  int packageid: @java_package ref
);

#keyset[fileid,keyName]
java_jarManifestMain(
  int fileid: @java_file ref,
  string keyName: string ref,
  string value: string ref
);

#keyset[fileid,entryName,keyName]
java_jarManifestEntries(
  int fileid: @java_file ref,
  string entryName: string ref,
  string keyName: string ref,
  string value: string ref
);

java_packages(
  unique int id: @java_package,
  string nodeName: string ref
);

java_primitives(
  unique int id: @java_primitive,
  string nodeName: string ref
);

java_modifiers(
  unique int id: @java_modifier,
  string nodeName: string ref
);

java_classes(
  unique int id: @java_class,
  string nodeName: string ref,
  int parentid: @java_package ref,
  int sourceid: @java_class ref
);

java_isRecord(
  unique int id: @java_class ref
);

java_interfaces(
  unique int id: @java_interface,
  string nodeName: string ref,
  int parentid: @java_package ref,
  int sourceid: @java_interface ref
);

java_fielddecls(
  unique int id: @java_fielddecl,
  int parentid: @java_reftype ref
);

#keyset[fieldId] #keyset[fieldDeclId,pos]
java_fieldDeclaredIn(
  int fieldId: @java_field ref,
  int fieldDeclId: @java_fielddecl ref,
  int pos: int ref
);

java_fields(
  unique int id: @java_field,
  string nodeName: string ref,
  int typeid: @java_type ref,
  int parentid: @java_reftype ref,
  int sourceid: @java_field ref
);

java_constrs(
  unique int id: @java_constructor,
  string nodeName: string ref,
  string signature: string ref,
  int typeid: @java_type ref,
  int parentid: @java_reftype ref,
  int sourceid: @java_constructor ref
);

java_methods(
  unique int id: @java_method,
  string nodeName: string ref,
  string signature: string ref,
  int typeid: @java_type ref,
  int parentid: @java_reftype ref,
  int sourceid: @java_method ref
);

#keyset[parentid,pos]
java_params(
  unique int id: @java_param,
  int typeid: @java_type ref,
  int pos: int ref,
  int parentid: @java_callable ref,
  int sourceid: @java_param ref
);

java_paramName(
  unique int id: @java_param ref,
  string nodeName: string ref
);

java_isVarargsParam(
  int param: @java_param ref
);

java_exceptions(
  unique int id: @java_exception,
  int typeid: @java_type ref,
  int parentid: @java_callable ref
);

java_isAnnotType(
  int interfaceid: @java_interface ref
);

java_isAnnotElem(
  int methodid: @java_method ref
);

java_annotValue(
  int parentid: @java_annotation ref,
  int id2: @java_method ref,
  unique int value: @java_expr ref
);

java_isEnumType(
  int classid: @java_class ref
);

java_isEnumConst(
  int fieldid: @java_field ref
);

#keyset[parentid,pos]
java_typeVars(
  unique int id: @java_typevariable,
  string nodeName: string ref,
  int pos: int ref,
  int kind: int ref, // deprecated
  int parentid: @java_typeorcallable ref
);

java_wildcards(
  unique int id: @java_wildcard,
  string nodeName: string ref,
  int kind: int ref
);

#keyset[parentid,pos]
java_typeBounds(
  unique int id: @java_typebound,
  int typeid: @java_reftype ref,
  int pos: int ref,
  int parentid: @java_boundedtype ref
);

#keyset[parentid,pos]
java_typeArgs(
  int argumentid: @java_reftype ref,
  int pos: int ref,
  int parentid: @java_typeorcallable ref
);

java_isParameterized(
  int memberid: @java_member ref
);

java_isRaw(
  int memberid: @java_member ref
);

java_erasure(
  unique int memberid: @java_member ref,
  int erasureid: @java_member ref
);

#keyset[classid] #keyset[parent]
java_isAnonymClass(
  int classid: @java_class ref,
  int parent: @java_classinstancexpr ref
);

#keyset[classid] #keyset[parent]
java_isLocalClass(
  int classid: @java_class ref,
  int parent: @java_localclassdeclstmt ref
);

java_isDefConstr(
  int constructorid: @java_constructor ref
);

#keyset[exprId]
java_lambdaKind(
  int exprId: @java_lambdaexpr ref,
  int bodyKind: int ref
);

java_arrays(
  unique int id: @java_array,
  string nodeName: string ref,
  int elementtypeid: @java_type ref,
  int dimension: int ref,
  int componenttypeid: @java_type ref
);

java_enclInReftype(
  unique int child: @java_reftype ref,
  int parent: @java_reftype ref
);

java_extendsReftype(
  int id1: @java_reftype ref,
  int id2: @java_classorinterface ref
);

java_implInterface(
  int id1: @java_classorarray ref,
  int id2: @java_interface ref
);

java_hasModifier(
  int id1: @java_modifiable ref,
  int id2: @java_modifier ref
);

java_imports(
  unique int id: @java_import,
  int holder: @java_typeorpackage ref,
  string name: string ref,
  int kind: int ref
);

#keyset[parent,idx]
java_stmts(
  unique int id: @java_stmt,
  int kind: int ref,
  int parent: @java_stmtparent ref,
  int idx: int ref,
  int bodydecl: @java_callable ref
);

@java_stmtparent = @java_callable | @java_stmt | @java_switchexpr;

case @java_stmt.kind of
  0 = @java_block
| 1 = @java_ifstmt
| 2 = @java_forstmt
| 3 = @java_enhancedforstmt
| 4 = @java_whilestmt
| 5 = @java_dostmt
| 6 = @java_trystmt
| 7 = @java_switchstmt
| 8 = @java_synchronizedstmt
| 9 = @java_returnstmt
| 10 = @java_throwstmt
| 11 = @java_breakstmt
| 12 = @java_continuestmt
| 13 = @java_emptystmt
| 14 = @java_exprstmt
| 15 = @java_labeledstmt
| 16 = @java_assertstmt
| 17 = @java_localvariabledeclstmt
| 18 = @java_localclassdeclstmt
| 19 = @java_constructorinvocationstmt
| 20 = @java_superconstructorinvocationstmt
| 21 = @java_case
| 22 = @java_catchclause
| 23 = @java_yieldstmt
;

#keyset[parent,idx]
java_exprs(
  unique int id: @java_expr,
  int kind: int ref,
  int typeid: @java_type ref,
  int parent: @java_exprparent ref,
  int idx: int ref
);

java_callableEnclosingExpr(
  unique int id: @java_expr ref,
  int callable_id: @java_callable ref
);

java_statementEnclosingExpr(
  unique int id: @java_expr ref,
  int statement_id: @java_stmt ref
);

java_isParenthesized(
  unique int id: @java_expr ref,
  int parentheses: int ref
);

case @java_expr.kind of
   1  = @java_arrayaccess
|  2  = @java_arraycreationexpr
|  3  = @java_arrayinit
|  4  = @java_assignexpr
|  5  = @java_assignaddexpr
|  6  = @java_assignsubexpr
|  7  = @java_assignmulexpr
|  8  = @java_assigndivexpr
|  9  = @java_assignremexpr
| 10  = @java_assignandexpr
| 11  = @java_assignorexpr
| 12  = @java_assignxorexpr
| 13  = @java_assignlshiftexpr
| 14  = @java_assignrshiftexpr
| 15  = @java_assignurshiftexpr
| 16  = @java_booleanliteral
| 17  = @java_integerliteral
| 18  = @java_longliteral
| 19  = @java_floatingpointliteral
| 20  = @java_doubleliteral
| 21  = @java_characterliteral
| 22  = @java_stringliteral
| 23  = @java_nullliteral
| 24  = @java_mulexpr
| 25  = @java_divexpr
| 26  = @java_remexpr
| 27  = @java_addexpr
| 28  = @java_subexpr
| 29  = @java_lshiftexpr
| 30  = @java_rshiftexpr
| 31  = @java_urshiftexpr
| 32  = @java_andbitexpr
| 33  = @java_orbitexpr
| 34  = @java_xorbitexpr
| 35  = @java_andlogicalexpr
| 36  = @java_orlogicalexpr
| 37  = @java_ltexpr
| 38  = @java_gtexpr
| 39  = @java_leexpr
| 40  = @java_geexpr
| 41  = @java_eqexpr
| 42  = @java_neexpr
| 43  = @java_postincexpr
| 44  = @java_postdecexpr
| 45  = @java_preincexpr
| 46  = @java_predecexpr
| 47  = @java_minusexpr
| 48  = @java_plusexpr
| 49  = @java_bitnotexpr
| 50  = @java_lognotexpr
| 51  = @java_castexpr
| 52  = @java_newexpr
| 53  = @java_conditionalexpr
| 54  = @java_parexpr         // deprecated
| 55  = @java_instanceofexpr
| 56  = @java_localvariabledeclexpr
| 57  = @java_typeliteral
| 58  = @java_thisaccess
| 59  = @java_superaccess
| 60  = @java_varaccess
| 61  = @java_methodaccess
| 62  = @java_unannotatedtypeaccess
| 63  = @java_arraytypeaccess
| 64  = @java_packageaccess
| 65  = @java_wildcardtypeaccess
| 66  = @java_declannotation
| 67  = @java_uniontypeaccess
| 68  = @java_lambdaexpr
| 69  = @java_memberref
| 70  = @java_annotatedtypeaccess
| 71  = @java_typeannotation
| 72  = @java_intersectiontypeaccess
| 73  = @java_switchexpr
;

@java_classinstancexpr = @java_newexpr | @java_lambdaexpr | @java_memberref

@java_annotation = @java_declannotation | @java_typeannotation
@java_typeaccess = @java_unannotatedtypeaccess | @java_annotatedtypeaccess

@java_assignment = @java_assignexpr
             | @java_assignop;

@java_unaryassignment = @java_postincexpr
                 | @java_postdecexpr
                 | @java_preincexpr
                 | @java_predecexpr;

@java_assignop = @java_assignaddexpr
             | @java_assignsubexpr
             | @java_assignmulexpr
             | @java_assigndivexpr
             | @java_assignremexpr
             | @java_assignandexpr
             | @java_assignorexpr
             | @java_assignxorexpr
             | @java_assignlshiftexpr
             | @java_assignrshiftexpr
             | @java_assignurshiftexpr;

@java_literal = @java_booleanliteral
             | @java_integerliteral
             | @java_longliteral
             | @java_floatingpointliteral
             | @java_doubleliteral
             | @java_characterliteral
             | @java_stringliteral
             | @java_nullliteral;

@java_binaryexpr = @java_mulexpr
             | @java_divexpr
             | @java_remexpr
             | @java_addexpr
             | @java_subexpr
             | @java_lshiftexpr
             | @java_rshiftexpr
             | @java_urshiftexpr
             | @java_andbitexpr
             | @java_orbitexpr
             | @java_xorbitexpr
             | @java_andlogicalexpr
             | @java_orlogicalexpr
             | @java_ltexpr
             | @java_gtexpr
             | @java_leexpr
             | @java_geexpr
             | @java_eqexpr
             | @java_neexpr;

@java_unaryexpr =   @java_postincexpr
             | @java_postdecexpr
             | @java_preincexpr
             | @java_predecexpr
             | @java_minusexpr
             | @java_plusexpr
             | @java_bitnotexpr
             | @java_lognotexpr;

@java_caller =  @java_classinstancexpr
         | @java_methodaccess
         | @java_constructorinvocationstmt
         | @java_superconstructorinvocationstmt;

java_callableBinding(
  unique int callerid: @java_caller ref,
  int callee: @java_callable ref
);

java_memberRefBinding(
  unique int id: @java_expr ref,
  int callable: @java_callable ref
);

@java_exprparent = @java_stmt | @java_expr | @java_callable | @java_field | @java_fielddecl | @java_class | @java_interface | @java_param | @java_localvar | @java_typevariable;

java_variableBinding(
  unique int expr: @java_varaccess ref,
  int variable: @java_variable ref
);

@java_variable = @java_localscopevariable | @java_field;

@java_localscopevariable = @java_localvar | @java_param;

java_localvars(
  unique int id: @java_localvar,
  string nodeName: string ref,
  int typeid: @java_type ref,
  int parentid: @java_localvariabledeclexpr ref
);

@java_namedexprorstmt = @java_breakstmt
                 | @java_continuestmt
                 | @java_labeledstmt
                 | @java_literal;

java_namestrings(
  string name: string ref,
  string value: string ref,
  unique int parent: @java_namedexprorstmt ref
);

/*
 * Modules
 */

#keyset[name]
java_modules(
  unique int id: @java_module,
  string name: string ref
);

java_isOpen(
  int id: @java_module ref
);

#keyset[fileId]
java_cumodule(
  int fileId: @java_file ref,
  int moduleId: @java_module ref
);

@java_directive = @java_requires
           | @java_exports
           | @java_opens
           | @java_uses
           | @java_provides

#keyset[directive]
java_directives(
  int id: @java_module ref,
  int directive: @java_directive ref
);

java_requires(
  unique int id: @java_requires,
  int target: @java_module ref
);

java_isTransitive(
  int id: @java_requires ref
);

java_isStatic(
  int id: @java_requires ref
);

java_exports(
  unique int id: @java_exports,
  int target: @java_package ref
);

java_exportsTo(
  int id: @java_exports ref,
  int target: @java_module ref
);

java_opens(
  unique int id: @java_opens,
  int target: @java_package ref
);

java_opensTo(
  int id: @java_opens ref,
  int target: @java_module ref
);

java_uses(
  unique int id: @java_uses,
  string serviceInterface: string ref
);

java_provides(
  unique int id: @java_provides,
  string serviceInterface: string ref
);

java_providesWith(
  int id: @java_provides ref,
  string serviceImpl: string ref
);

/*
 * Javadoc
 */

java_javadoc(
  unique int id: @java_javadoc
);

java_isNormalComment(
  int commentid : @java_javadoc ref
);

java_isEolComment(
  int commentid : @java_javadoc ref
);

java_hasJavadoc(
  int documentableid: @java_member ref,
  int javadocid: @java_javadoc ref
);

#keyset[parentid,idx]
java_javadocTag(
  unique int id: @java_javadocTag,
  string name: string ref,
  int parentid: @java_javadocParent ref,
  int idx: int ref
);

#keyset[parentid,idx]
java_javadocText(
  unique int id: @java_javadocText,
  string text: string ref,
  int parentid: @java_javadocParent ref,
  int idx: int ref
);

@java_javadocParent = @java_javadoc | @java_javadocTag;
@java_javadocElement = @java_javadocTag | @java_javadocText;

@java_typeorpackage = @java_type | @java_package;

@java_typeorcallable = @java_type | @java_callable;
@java_classorinterface = @java_interface | @java_class;
@java_boundedtype = @java_typevariable | @java_wildcard;
@java_reftype = @java_classorinterface | @java_array | @java_boundedtype;
@java_classorarray = @java_class | @java_array;
@java_type = @java_primitive | @java_reftype;
@java_callable = @java_method | @java_constructor;
@java_element = @java_file | @java_package | @java_primitive | @java_class | @java_interface | @java_method | @java_constructor | @java_modifier | @java_param | @java_exception | @java_field |
           @java_annotation | @java_boundedtype | @java_array | @java_localvar | @java_expr | @java_stmt | @java_import | @java_fielddecl;

@java_modifiable = @java_member_modifiable| @java_param | @java_localvar ;

@java_member_modifiable = @java_class | @java_interface | @java_method | @java_constructor | @java_field ;

@java_member = @java_method | @java_constructor | @java_field | @java_reftype ;

@java_locatable = @java_file | @java_class | @java_interface | @java_fielddecl | @java_field | @java_constructor | @java_method | @java_param | @java_exception
             | @java_boundedtype | @java_typebound | @java_array | @java_primitive
             | @java_import | @java_stmt | @java_expr | @java_localvar | @java_javadoc | @java_javadocTag | @java_javadocText
             | @java_xmllocatable;

@java_top = @java_element | @java_locatable | @java_folder;

/*
 * XML Files
 */

java_xmlEncoding(
  unique int id: @java_file ref,
  string encoding: string ref
);

java_xmlDTDs(
  unique int id: @java_xmldtd,
  string root: string ref,
  string publicId: string ref,
  string systemId: string ref,
  int fileid: @java_file ref
);

java_xmlElements(
  unique int id: @java_xmlelement,
  string name: string ref,
  int parentid: @java_xmlparent ref,
  int idx: int ref,
  int fileid: @java_file ref
);

java_xmlAttrs(
  unique int id: @java_xmlattribute,
  int elementid: @java_xmlelement ref,
  string name: string ref,
  string value: string ref,
  int idx: int ref,
  int fileid: @java_file ref
);

java_xmlNs(
  int id: @java_xmlnamespace,
  string prefixName: string ref,
  string URI: string ref,
  int fileid: @java_file ref
);

java_xmlHasNs(
  int elementId: @java_xmlnamespaceable ref,
  int nsId: @java_xmlnamespace ref,
  int fileid: @java_file ref
);

java_xmlComments(
  unique int id: @java_xmlcomment,
  string text: string ref,
  int parentid: @java_xmlparent ref,
  int fileid: @java_file ref
);

java_xmlChars(
  unique int id: @java_xmlcharacters,
  string text: string ref,
  int parentid: @java_xmlparent ref,
  int idx: int ref,
  int isCDATA: int ref,
  int fileid: @java_file ref
);

@java_xmlparent = @java_file | @java_xmlelement;
@java_xmlnamespaceable = @java_xmlelement | @java_xmlattribute;

java_xmllocations(
  int xmlElement: @java_xmllocatable ref,
  int location: @java_location_default ref
);

@java_xmllocatable = @java_xmlcharacters | @java_xmlelement | @java_xmlcomment | @java_xmlattribute | @java_xmldtd | @java_file | @java_xmlnamespace;

/*
 * configuration files with key value pairs
 */

java_configs(
  unique int id: @java_config
);

java_configNames(
  unique int id: @java_configName,
  int config: @java_config ref,
  string name: string ref
);

java_configValues(
  unique int id: @java_configValue,
  int config: @java_config ref,
  string value: string ref
);

java_configLocations(
  int locatable: @java_configLocatable ref,
  int location: @java_location_default ref
);

@java_configLocatable = @java_config | @java_configName | @java_configValue;


/**
 * An invocation of the compiler. Note that more than one file may be
 * compiled per invocation. For example, this command compiles three
 * source files:
 *
 *   gcc -c f1.c f2.c f3.c
 *
 * The `id` simply identifies the invocation, while `cwd` is the working
 * directory from which the compiler was invoked.
 */
cpp_compilations(
    /**
     * An invocation of the compiler. Note that more than one file may
     * be compiled per invocation. For example, this command compiles
     * three source files:
     *
     *   gcc -c f1.c f2.c f3.c
     */
    unique int id : @cpp_compilation,
    string cwd : string ref
);

/**
 * The arguments that were passed to the extractor for a compiler
 * invocation. If `id` is for the compiler invocation
 *
 *   gcc -c f1.c f2.c f3.c
 *
 * then typically there will be rows for
 *
 * num | arg
 * --- | ---
 * 0   | *path to extractor*
 * 1   | `--mimic`
 * 2   | `/usr/bin/gcc`
 * 3   | `-c`
 * 4   | f1.c
 * 5   | f2.c
 * 6   | f3.c
 */
#keyset[id, num]
cpp_compilation_args(
    int id : @cpp_compilation ref,
    int num : int ref,
    string arg : string ref
);

/**
 * The source files that are compiled by a compiler invocation.
 * If `id` is for the compiler invocation
 *
 *   gcc -c f1.c f2.c f3.c
 *
 * then there will be rows for
 *
 * num | arg
 * --- | ---
 * 0   | f1.c
 * 1   | f2.c
 * 2   | f3.c
 *
 * Note that even if those files `#include` headers, those headers
 * do not appear as rows.
 */
#keyset[id, num]
cpp_compilation_compiling_files(
    int id : @cpp_compilation ref,
    int num : int ref,
    int file : @cpp_file ref
);

/**
 * The time taken by the extractor for a compiler invocation.
 *
 * For each file `num`, there will be rows for
 *
 * kind | seconds
 * ---- | ---
 * 1    | CPU seconds used by the extractor frontend
 * 2    | Elapsed seconds during the extractor frontend
 * 3    | CPU seconds used by the extractor backend
 * 4    | Elapsed seconds during the extractor backend
 */
#keyset[id, num, kind]
cpp_compilation_time(
    int id : @cpp_compilation ref,
    int num : int ref,
    /* kind:
       1 = frontend_cpu_seconds
       2 = frontend_elapsed_seconds
       3 = extractor_cpu_seconds
       4 = extractor_elapsed_seconds
    */
    int kind : int ref,
    float seconds : float ref
);

/**
 * An error or warning generated by the extractor.
 * The diagnostic message `diagnostic` was generated during compiler
 * invocation `compilation`, and is the `file_number_diagnostic_number`th
 * message generated while extracting the `file_number`th file of that
 * invocation.
 */
#keyset[compilation, file_number, file_number_diagnostic_number]
cpp_diagnostic_for(
    int diagnostic : @cpp_diagnostic ref,
    int compilation : @cpp_compilation ref,
    int file_number : int ref,
    int file_number_diagnostic_number : int ref
);

/**
 * If extraction was successful, then `cpu_seconds` and
 * `elapsed_seconds` are the CPU time and elapsed time (respectively)
 * that extraction took for compiler invocation `id`.
 */
cpp_compilation_finished(
    unique int id : @cpp_compilation ref,
    float cpu_seconds : float ref,
    float elapsed_seconds : float ref
);


/**
 * External data, loaded from CSV files during snapshot creation. See
 * [Tutorial: Incorporating external data](https://help.semmle.com/wiki/display/SD/Tutorial%3A+Incorporating+external+data)
 * for more information.
 */
cpp_externalData(
    int id : @cpp_externalDataElement,
    string path : string ref,
    int column: int ref,
    string value : string ref
);

/**
 * The date of the snapshot.
 */
cpp_snapshotDate(unique date snapshotDate : date ref);


/**
 * Data used by the 'duplicate code' detection.
 */
cpp_duplicateCode(
    unique int id : @cpp_duplication,
    string relativePath : string ref,
    int equivClass : int ref
);

/**
 * Data used by the 'similar code' detection.
 */
cpp_similarCode(
    unique int id : @cpp_similarity,
    string relativePath : string ref,
    int equivClass : int ref
);

/**
 * Data used by the 'duplicate code' and 'similar code' detection.
 */
@cpp_duplication_or_similarity = @cpp_duplication | @cpp_similarity

/**
 * Data used by the 'duplicate code' and 'similar code' detection.
 */
#keyset[id, offset]
cpp_tokens(
    int id : @cpp_duplication_or_similarity ref,
    int offset : int ref,
    int beginLine : int ref,
    int beginColumn : int ref,
    int endLine : int ref,
    int endColumn : int ref
);

/**
 * Information about packages that provide code used during compilation.
 * The `id` is just a unique identifier.
 * The `namespace` is typically the name of the package manager that
 * provided the package (e.g. "dpkg" or "yum").
 * The `package_name` is the name of the package, and `version` is its
 * version (as a string).
 */
cpp_external_packages(
    unique int id: @cpp_external_package,
    string namespace : string ref,
    string package_name : string ref,
    string version : string ref
);

/**
 * Holds if File `fileid` was provided by package `package`.
 */
cpp_header_to_external_package(
    int fileid : @cpp_file ref,
    int package : @cpp_external_package ref
);

/*
 * Version history
 */

cpp_svnentries(
    unique int id : @cpp_svnentry,
    string revision : string ref,
    string author : string ref,
    date revisionDate : date ref,
    int changeSize : int ref
)

cpp_svnaffectedfiles(
    int id : @cpp_svnentry ref,
    int file : @cpp_file ref,
    string action : string ref
)

cpp_svnentrymsg(
    unique int id : @cpp_svnentry ref,
    string message : string ref
)

cpp_svnchurn(
    int commit : @cpp_svnentry ref,
    int file : @cpp_file ref,
    int addedLines : int ref,
    int deletedLines : int ref
)

/*
 * C++ dbscheme
 */

@cpp_location = @cpp_location_stmt | @cpp_location_expr | @cpp_location_default ;

/**
 * The location of an element that is not an expression or a statement.
 * The location spans column `startcolumn` of line `startline` to
 * column `endcolumn` of line `endline` in file `file`.
 * For more information, see
 * [Locations](https://help.semmle.com/QL/learn-ql/ql/locations.html).
 */
cpp_locations_default(
    /** The location of an element that is not an expression or a statement. */
    unique int id: @cpp_location_default,
    int container: @cpp_container ref,
    int startLine: int ref,
    int startColumn: int ref,
    int endLine: int ref,
    int endColumn: int ref
);

/**
 * The location of a statement.
 * The location spans column `startcolumn` of line `startline` to
 * column `endcolumn` of line `endline` in file `file`.
 * For more information, see
 * [Locations](https://help.semmle.com/QL/learn-ql/ql/locations.html).
 */
cpp_locations_stmt(
    /** The location of a statement. */
    unique int id: @cpp_location_stmt,
    int container: @cpp_container ref,
    int startLine: int ref,
    int startColumn: int ref,
    int endLine: int ref,
    int endColumn: int ref
);

/**
 * The location of an expression.
 * The location spans column `startcolumn` of line `startline` to
 * column `endcolumn` of line `endline` in file `file`.
 * For more information, see
 * [Locations](https://help.semmle.com/QL/learn-ql/ql/locations.html).
 */
cpp_locations_expr(
    /** The location of an expression. */
    unique int id: @cpp_location_expr,
    int container: @cpp_container ref,
    int startLine: int ref,
    int startColumn: int ref,
    int endLine: int ref,
    int endColumn: int ref
);

/** An element for which line-count information is available. */
@cpp_sourceline = @cpp_file | @cpp_function | @cpp_variable | @cpp_enumconstant | @cpp_xmllocatable;

cpp_numlines(
    int element_id: @cpp_sourceline ref,
    int num_lines: int ref,
    int num_code: int ref,
    int num_comment: int ref
);

cpp_diagnostics(
    unique int id: @cpp_diagnostic,
    int severity: int ref,
    string error_tag: string ref,
    string error_message: string ref,
    string full_error_message: string ref,
    int location: @cpp_location_default ref
);

/*
  fromSource(0) = unknown,
  fromSource(1) = from source,
  fromSource(2) = from library
*/
cpp_files(
    unique int id: @cpp_file,
    string name: string ref,
    string simple: string ref,
    string ext: string ref,
    int fromSource: int ref
);

cpp_folders(
    unique int id: @cpp_folder,
    string name: string ref,
    string simple: string ref
);

@cpp_container = @cpp_folder | @cpp_file

cpp_containerparent(
    int parent: @cpp_container ref,
    unique int child: @cpp_container ref
);

cpp_fileannotations(
    int id: @cpp_file ref,
    int kind: int ref,
    string name: string ref,
    string value: string ref
);

cpp_inmacroexpansion(
    int id: @cpp_element ref,
    int inv: @cpp_macroinvocation ref
);

cpp_affectedbymacroexpansion(
    int id: @cpp_element ref,
    int inv: @cpp_macroinvocation ref
);

/*
  case @cpp_macroinvocations.kind of
    1 = macro expansion
  | 2 = other macro reference
  ;
*/
cpp_macroinvocations(
    unique int id: @cpp_macroinvocation,
    int macro_id: @cpp_ppd_define ref,
    int location: @cpp_location_default ref,
    int kind: int ref
);

cpp_macroparent(
    unique int id: @cpp_macroinvocation ref,
    int parent_id: @cpp_macroinvocation ref
);

// a macroinvocation may be part of another location
// the way to find a constant expression that uses a macro
// is thus to find a constant expression that has a location
// to which a macro invocation is bound
cpp_macrolocationbind(
    int id: @cpp_macroinvocation ref,
    int location: @cpp_location ref
);

#keyset[invocation, argument_index]
cpp_macro_argument_unexpanded(
    int invocation: @cpp_macroinvocation ref,
    int argument_index: int ref,
    string text: string ref
);

#keyset[invocation, argument_index]
cpp_macro_argument_expanded(
    int invocation: @cpp_macroinvocation ref,
    int argument_index: int ref,
    string text: string ref
);

/*
  case @cpp_function.kind of
    1 = normal
  | 2 = constructor
  | 3 = destructor
  | 4 = conversion
  | 5 = operator
  | 6 = builtin     // GCC built-in functions, e.g. __builtin___memcpy_chk
  ;
*/
cpp_functions(
    unique int id: @cpp_function,
    string name: string ref,
    int kind: int ref
);

cpp_function_entry_point(int id: @cpp_function ref, unique int entry_point: @cpp_stmt ref);

cpp_function_return_type(int id: @cpp_function ref, int return_type: @cpp_type ref);

/** If `function` is a coroutine, then this gives the
    std::experimental::resumable_traits instance associated with it,
    and the variables representing the `handle` and `promise` for it. */
cpp_coroutine(
  unique int function: @cpp_function ref,
  int traits: @cpp_type ref,
  int handle: @cpp_variable ref,
  int promise: @cpp_variable ref
);

/** The `new` function used for allocating the coroutine state, if any. */
cpp_coroutine_new(
  unique int function: @cpp_function ref,
  int new: @cpp_function ref
);

/** The `delete` function used for deallocating the coroutine state, if any. */
cpp_coroutine_delete(
  unique int function: @cpp_function ref,
  int delete: @cpp_function ref
);

cpp_purefunctions(unique int id: @cpp_function ref);

cpp_function_deleted(unique int id: @cpp_function ref);

cpp_function_defaulted(unique int id: @cpp_function ref);

cpp_member_function_this_type(unique int id: @cpp_function ref, int this_type: @cpp_type ref);

#keyset[id, type_id]
cpp_fun_decls(
    int id: @cpp_fun_decl,
    int function: @cpp_function ref,
    int type_id: @cpp_type ref,
    string name: string ref,
    int location: @cpp_location_default ref
);
cpp_fun_def(unique int id: @cpp_fun_decl ref);
cpp_fun_specialized(unique int id: @cpp_fun_decl ref);
cpp_fun_implicit(unique int id: @cpp_fun_decl ref);
cpp_fun_decl_specifiers(
    int id: @cpp_fun_decl ref,
    string name: string ref
)
#keyset[fun_decl, index]
cpp_fun_decl_throws(
    int fun_decl: @cpp_fun_decl ref,
    int index: int ref,
    int type_id: @cpp_type ref
);
/* an empty throw specification is different from none */
cpp_fun_decl_empty_throws(unique int fun_decl: @cpp_fun_decl ref);
cpp_fun_decl_noexcept(
    int fun_decl: @cpp_fun_decl ref,
    int constant: @cpp_expr ref
);
cpp_fun_decl_empty_noexcept(int fun_decl: @cpp_fun_decl ref);
cpp_fun_decl_typedef_type(
    unique int fun_decl: @cpp_fun_decl ref,
    int typedeftype_id: @cpp_usertype ref
);

cpp_param_decl_bind(
    unique int id: @cpp_var_decl ref,
    int index: int ref,
    int fun_decl: @cpp_fun_decl ref
);

#keyset[id, type_id]
cpp_var_decls(
    int id: @cpp_var_decl,
    int variable: @cpp_variable ref,
    int type_id: @cpp_type ref,
    string name: string ref,
    int location: @cpp_location_default ref
);
cpp_var_def(unique int id: @cpp_var_decl ref);
cpp_var_decl_specifiers(
    int id: @cpp_var_decl ref,
    string name: string ref
)

cpp_type_decls(
    unique int id: @cpp_type_decl,
    int type_id: @cpp_type ref,
    int location: @cpp_location_default ref
);
cpp_type_def(unique int id: @cpp_type_decl ref);
cpp_type_decl_top(
    unique int type_decl: @cpp_type_decl ref
);

cpp_namespace_decls(
    unique int id: @cpp_namespace_decl,
    int namespace_id: @cpp_namespace ref,
    int location: @cpp_location_default ref,
    int bodylocation: @cpp_location_default ref
);

cpp_usings(
    unique int id: @cpp_using,
    int element_id: @cpp_element ref,
    int location: @cpp_location_default ref
);

/** The element which contains the `using` declaration. */
cpp_using_container(
    int parent: @cpp_element ref,
    int child: @cpp_using ref
);

cpp_static_asserts(
    unique int id: @cpp_static_assert,
    int condition : @cpp_expr ref,
    string message : string ref,
    int location: @cpp_location_default ref,
    int enclosing : @cpp_element ref
);

// each function has an ordered list of parameters
#keyset[id, type_id]
#keyset[function, index, type_id]
cpp_params(
    int id: @cpp_parameter,
    int function: @cpp_functionorblock ref,
    int index: int ref,
    int type_id: @cpp_type ref
);

cpp_overrides(int new: @cpp_function ref, int old: @cpp_function ref);

#keyset[id, type_id]
cpp_membervariables(
    int id: @cpp_membervariable,
    int type_id: @cpp_type ref,
    string name: string ref
);

#keyset[id, type_id]
cpp_globalvariables(
    int id: @cpp_globalvariable,
    int type_id: @cpp_type ref,
    string name: string ref
);

#keyset[id, type_id]
cpp_localvariables(
    int id: @cpp_localvariable,
    int type_id: @cpp_type ref,
    string name: string ref
);

cpp_autoderivation(
    unique int var: @cpp_variable ref,
    int derivation_type: @cpp_type ref
);

cpp_enumconstants(
    unique int id: @cpp_enumconstant,
    int parent: @cpp_usertype ref,
    int index: int ref,
    int type_id: @cpp_type ref,
    string name: string ref,
    int location: @cpp_location_default ref
);

@cpp_variable = @cpp_localscopevariable | @cpp_globalvariable | @cpp_membervariable;

@cpp_localscopevariable = @cpp_localvariable | @cpp_parameter;

/*
  Built-in types are the fundamental types, e.g., integral, floating, and void.

  case @cpp_builtintype.kind of
    1 = error
  | 2 = unknown
  | 3 = void
  | 4 = boolean
  | 5 = char
  | 6 = unsigned_char
  | 7 = signed_char
  | 8 = short
  | 9 = unsigned_short
  | 10 = signed_short
  | 11 = int
  | 12 = unsigned_int
  | 13 = signed_int
  | 14 = long
  | 15 = unsigned_long
  | 16 = signed_long
  | 17 = long_long
  | 18 = unsigned_long_long
  | 19 = signed_long_long
  | 20 = __int8                 // Microsoft-specific
  | 21 = __int16                // Microsoft-specific
  | 22 = __int32                // Microsoft-specific
  | 23 = __int64                // Microsoft-specific
  | 24 = float
  | 25 = double
  | 26 = long_double
  | 27 = _Complex_float         // C99-specific
  | 28 = _Complex_double        // C99-specific
  | 29 = _Complex_long double   // C99-specific
  | 30 = _Imaginary_float       // C99-specific
  | 31 = _Imaginary_double      // C99-specific
  | 32 = _Imaginary_long_double // C99-specific
  | 33 = wchar_t                // Microsoft-specific
  | 34 = decltype_nullptr       // C++11
  | 35 = __int128
  | 36 = unsigned___int128
  | 37 = signed___int128
  | 38 = __float128
  | 39 = _Complex___float128
  | 40 = _Decimal32
  | 41 = _Decimal64
  | 42 = _Decimal128
  | 43 = char16_t
  | 44 = char32_t
  | 45 = _Float32
  | 46 = _Float32x
  | 47 = _Float64
  | 48 = _Float64x
  | 49 = _Float128
  | 50 = _Float128x
  | 51 = char8_t
  ;
*/
cpp_builtintypes(
    unique int id: @cpp_builtintype,
    string name: string ref,
    int kind: int ref,
    int size: int ref,
    int sign: int ref,
    int alignment: int ref
);

/*
  Derived types are types that are directly derived from existing types and
  point to, refer to, transform type data to return a new type.

  case @cpp_derivedtype.kind of
    1 = pointer
  | 2 = reference
  | 3 = type_with_specifiers
  | 4 = array
  | 5 = gnu_vector
  | 6 = routineptr
  | 7 = routinereference
  | 8 = rvalue_reference // C++11
// ... 9 type_conforming_to_protocols deprecated
  | 10 = block
  ;
*/
cpp_derivedtypes(
    unique int id: @cpp_derivedtype,
    string name: string ref,
    int kind: int ref,
    int type_id: @cpp_type ref
);

cpp_pointerishsize(unique int id: @cpp_derivedtype ref,
    int size: int ref,
    int alignment: int ref);

cpp_arraysizes(
    unique int id: @cpp_derivedtype ref,
    int num_elements: int ref,
    int bytesize: int ref,
    int alignment: int ref
);

cpp_typedefbase(
    unique int id: @cpp_usertype ref,
    int type_id: @cpp_type ref
);

cpp_decltypes(
    unique int id: @cpp_decltype,
    int expr: @cpp_expr ref,
    int base_type: @cpp_type ref,
    boolean parentheses_would_change_meaning: boolean ref
);

/*
  case @cpp_usertype.kind of
    1 = struct
  | 2 = class
  | 3 = union
  | 4 = enum
  | 5 = typedef                       // classic C: typedef typedef type name
  | 6 = template
  | 7 = template_parameter
  | 8 = template_template_parameter
  | 9 = proxy_class                   // a proxy class associated with a template parameter
// ... 10 objc_class deprecated
// ... 11 objc_protocol deprecated
// ... 12 objc_category deprecated
  | 13 = scoped_enum
  | 14 = using_alias                  // a using name = type style typedef
  ;
*/
cpp_usertypes(
    unique int id: @cpp_usertype,
    string name: string ref,
    int kind: int ref
);

cpp_usertypesize(
    unique int id: @cpp_usertype ref,
    int size: int ref,
    int alignment: int ref
);

cpp_usertype_final(unique int id: @cpp_usertype ref);

cpp_usertype_uuid(
    unique int id: @cpp_usertype ref,
    unique string uuid: string ref
);

cpp_mangled_name(
    unique int id: @cpp_declaration ref,
    int mangled_name : @cpp_mangledname
);

cpp_is_pod_class(unique int id: @cpp_usertype ref);
cpp_is_standard_layout_class(unique int id: @cpp_usertype ref);

cpp_is_complete(unique int id: @cpp_usertype ref);

cpp_is_class_template(unique int id: @cpp_usertype ref);
cpp_class_instantiation(
    int to: @cpp_usertype ref,
    int from: @cpp_usertype ref
);
cpp_class_template_argument(
    int type_id: @cpp_usertype ref,
    int index: int ref,
    int arg_type: @cpp_type ref
);
cpp_class_template_argument_value(
    int type_id: @cpp_usertype ref,
    int index: int ref,
    int arg_value: @cpp_expr ref
);

cpp_is_proxy_class_for(
    unique int id: @cpp_usertype ref,
    unique int templ_param_id: @cpp_usertype ref
);

cpp_type_mentions(
    unique int id: @cpp_type_mention,
    int type_id: @cpp_type ref,
    int location: @cpp_location ref,
    // a_symbol_reference_kind from the EDG frontend.  See symbol_ref.h there.
    int kind: int ref
);

cpp_is_function_template(unique int id: @cpp_function ref);
cpp_function_instantiation(
    unique int to: @cpp_function ref,
    int from: @cpp_function ref
);
cpp_function_template_argument(
    int function_id: @cpp_function ref,
    int index: int ref,
    int arg_type: @cpp_type ref
);
cpp_function_template_argument_value(
    int function_id: @cpp_function ref,
    int index: int ref,
    int arg_value: @cpp_expr ref
);

cpp_is_variable_template(unique int id: @cpp_variable ref);
cpp_variable_instantiation(
    unique int to: @cpp_variable ref,
    int from: @cpp_variable ref
);
cpp_variable_template_argument(
    int variable_id: @cpp_variable ref,
    int index: int ref,
    int arg_type: @cpp_type ref
);
cpp_variable_template_argument_value(
    int variable_id: @cpp_variable ref,
    int index: int ref,
    int arg_value: @cpp_expr ref
);

/*
  Fixed point types
  precision(1) = short, precision(2) = default, precision(3) = long
  is_unsigned(1) = unsigned is_unsigned(2) = signed
  is_fract_type(1) = declared with _Fract
  saturating(1) = declared with _Sat
*/
/* TODO
cpp_fixedpointtypes(
    unique int id: @cpp_fixedpointtype,
    int precision: int ref,
    int is_unsigned: int ref,
    int is_fract_type: int ref,
    int saturating: int ref);
*/

cpp_routinetypes(
    unique int id: @cpp_routinetype,
    int return_type: @cpp_type ref
);

cpp_routinetypeargs(
    int routine: @cpp_routinetype ref,
    int index: int ref,
    int type_id: @cpp_type ref
);

cpp_ptrtomembers(
    unique int id: @cpp_ptrtomember,
    int type_id: @cpp_type ref,
    int class_id: @cpp_type ref
);

/*
 specifiers for types, functions, and variables

    "public",
    "protected",
    "private",

    "const",
    "volatile",
    "static",

    "pure",
    "virtual",
    "sealed", // Microsoft
    "__interface", // Microsoft
    "inline",
    "explicit",

    "near", // near far extension
    "far", // near far extension
    "__ptr32", // Microsoft
    "__ptr64", // Microsoft
    "__sptr", // Microsoft
    "__uptr", // Microsoft
    "dllimport", // Microsoft
    "dllexport", // Microsoft
    "thread", // Microsoft
    "naked", // Microsoft
    "microsoft_inline", // Microsoft
    "forceinline", // Microsoft
    "selectany", // Microsoft
    "nothrow", // Microsoft
    "novtable", // Microsoft
    "noreturn", // Microsoft
    "noinline", // Microsoft
    "noalias", // Microsoft
    "restrict", // Microsoft
*/

cpp_specifiers(
    unique int id: @cpp_specifier,
    unique string str: string ref
);

cpp_typespecifiers(
    int type_id: @cpp_type ref,
    int spec_id: @cpp_specifier ref
);

cpp_funspecifiers(
    int func_id: @cpp_function ref,
    int spec_id: @cpp_specifier ref
);

cpp_varspecifiers(
    int var_id: @cpp_accessible ref,
    int spec_id: @cpp_specifier ref
);

cpp_attributes(
    unique int id: @cpp_attribute,
    int kind: int ref,
    string name: string ref,
    string name_space: string ref,
    int location: @cpp_location_default ref
);

case @cpp_attribute.kind of
  0 = @cpp_gnuattribute
| 1 = @cpp_stdattribute
| 2 = @cpp_declspec
| 3 = @cpp_msattribute
| 4 = @cpp_alignas
// ... 5 @cpp_objc_propertyattribute deprecated
;

cpp_attribute_args(
    unique int id: @cpp_attribute_arg,
    int kind: int ref,
    int attribute: @cpp_attribute ref,
    int index: int ref,
    int location: @cpp_location_default ref
);

case @cpp_attribute_arg.kind of
  0 = @cpp_attribute_arg_empty
| 1 = @cpp_attribute_arg_token
| 2 = @cpp_attribute_arg_constant
| 3 = @cpp_attribute_arg_type
;

cpp_attribute_arg_value(
    unique int arg: @cpp_attribute_arg ref,
    string value: string ref
);
cpp_attribute_arg_type(
    unique int arg: @cpp_attribute_arg ref,
    int type_id: @cpp_type ref
);
cpp_attribute_arg_name(
    unique int arg: @cpp_attribute_arg ref,
    string name: string ref
);

cpp_typeattributes(
    int type_id: @cpp_type ref,
    int spec_id: @cpp_attribute ref
);

cpp_funcattributes(
    int func_id: @cpp_function ref,
    int spec_id: @cpp_attribute ref
);

cpp_varattributes(
    int var_id: @cpp_accessible ref,
    int spec_id: @cpp_attribute ref
);

cpp_stmtattributes(
    int stmt_id: @cpp_stmt ref,
    int spec_id: @cpp_attribute ref
);

@cpp_type = @cpp_builtintype
      | @cpp_derivedtype
      | @cpp_usertype
      /* TODO | @cpp_fixedpointtype */
      | @cpp_routinetype
      | @cpp_ptrtomember
      | @cpp_decltype;

cpp_unspecifiedtype(
    unique int type_id: @cpp_type ref,
    int unspecified_type_id: @cpp_type ref
);

cpp_member(
    int parent: @cpp_type ref,
    int index: int ref,
    int child: @cpp_member ref
);

@cpp_enclosingfunction_child = @cpp_usertype | @cpp_variable | @cpp_namespace

cpp_enclosingfunction(
    unique int child: @cpp_enclosingfunction_child ref,
    int parent: @cpp_function ref
);

cpp_derivations(
    unique int derivation: @cpp_derivation,
    int sub: @cpp_type ref,
    int index: int ref,
    int super: @cpp_type ref,
    int location: @cpp_location_default ref
);

cpp_derspecifiers(
    int der_id: @cpp_derivation ref,
    int spec_id: @cpp_specifier ref
);

/**
 * Contains the byte offset of the base class subobject within the derived
 * class. Only holds for non-virtual base classes, but see table
 * `virtual_base_offsets` for offsets of virtual base class subobjects.
 */
cpp_direct_base_offsets(
    unique int der_id: @cpp_derivation ref,
    int offset: int ref
);

/**
 * Contains the byte offset of the virtual base class subobject for class
 * `super` within a most-derived object of class `sub`. `super` can be either a
 * direct or indirect base class.
 */
#keyset[sub, super]
cpp_virtual_base_offsets(
    int sub: @cpp_usertype ref,
    int super: @cpp_usertype ref,
    int offset: int ref
);

cpp_frienddecls(
    unique int id: @cpp_frienddecl,
    int type_id: @cpp_type ref,
    int decl_id: @cpp_declaration ref,
    int location: @cpp_location_default ref
);

@cpp_declaredtype = @cpp_usertype ;

@cpp_declaration = @cpp_function
             | @cpp_declaredtype
             | @cpp_variable
             | @cpp_enumconstant
             | @cpp_frienddecl;

@cpp_member = @cpp_membervariable
        | @cpp_function
        | @cpp_declaredtype
        | @cpp_enumconstant;

@cpp_locatable = @cpp_diagnostic
           | @cpp_declaration
           | @cpp_ppd_include
           | @cpp_ppd_define
           | @cpp_macroinvocation
           /*| @cpp_funcall*/
           | @cpp_xmllocatable
           | @cpp_attribute
           | @cpp_attribute_arg;

@cpp_namedscope = @cpp_namespace | @cpp_usertype;

@cpp_element = @cpp_locatable
         | @cpp_file
         | @cpp_folder
         | @cpp_specifier
         | @cpp_type
         | @cpp_expr
         | @cpp_namespace
         | @cpp_initialiser
         | @cpp_stmt
         | @cpp_derivation
         | @cpp_comment
         | @cpp_preprocdirect
         | @cpp_fun_decl
         | @cpp_var_decl
         | @cpp_type_decl
         | @cpp_namespace_decl
         | @cpp_using
         | @cpp_namequalifier
         | @cpp_specialnamequalifyingelement
         | @cpp_static_assert
         | @cpp_type_mention
         | @cpp_lambdacapture;

@cpp_exprparent = @cpp_element;

cpp_comments(
    unique int id: @cpp_comment,
    string contents: string ref,
    int location: @cpp_location_default ref
);

cpp_commentbinding(
    int id: @cpp_comment ref,
    int element: @cpp_element ref
);

cpp_exprconv(
    int converted: @cpp_expr ref,
    unique int conversion: @cpp_expr ref
);

cpp_compgenerated(unique int id: @cpp_element ref);

/**
 * `destructor_call` destructs the `i`'th entity that should be
 * destructed following `element`. Note that entities should be
 * destructed in reverse construction order, so for a given `element`
 * these should be called from highest to lowest `i`.
 */
#keyset[element, destructor_call]
#keyset[element, i]
cpp_synthetic_destructor_call(
    int element: @cpp_element ref,
    int i: int ref,
    int destructor_call: @cpp_routineexpr ref
);

cpp_namespaces(
    unique int id: @cpp_namespace,
    string name: string ref
);

cpp_namespace_inline(
    unique int id: @cpp_namespace ref
);

cpp_namespacembrs(
    int parentid: @cpp_namespace ref,
    unique int memberid: @cpp_namespacembr ref
);

@cpp_namespacembr = @cpp_declaration | @cpp_namespace;

cpp_exprparents(
    int expr_id: @cpp_expr ref,
    int child_index: int ref,
    int parent_id: @cpp_exprparent ref
);

cpp_expr_isload(unique int expr_id: @cpp_expr ref);

@cpp_cast = @cpp_c_style_cast
      | @cpp_const_cast
      | @cpp_dynamic_cast
      | @cpp_reinterpret_cast
      | @cpp_static_cast
      ;

/*
case @cpp_conversion.kind of
  0 = @cpp_simple_conversion           // a numeric conversion, qualification conversion, or a reinterpret_cast
| 1 = @cpp_bool_conversion             // conversion to 'bool'
| 2 = @cpp_base_class_conversion       // a derived-to-base conversion
| 3 = @cpp_derived_class_conversion    // a base-to-derived conversion
| 4 = @cpp_pm_base_class_conversion    // a derived-to-base conversion of a pointer to member
| 5 = @cpp_pm_derived_class_conversion // a base-to-derived conversion of a pointer to member
| 6 = @cpp_glvalue_adjust              // an adjustment of the type of a glvalue
| 7 = @cpp_prvalue_adjust              // an adjustment of the type of a prvalue
;
*/
/**
 * Describes the semantics represented by a cast expression. This is largely
 * independent of the source syntax of the cast, so it is separate from the
 * regular expression kind.
 */
cpp_conversionkinds(
    unique int expr_id: @cpp_cast ref,
    int kind: int ref
);

@cpp_conversion = @cpp_cast
            | @cpp_array_to_pointer
            | @cpp_parexpr
            | @cpp_reference_to
            | @cpp_ref_indirect
            | @cpp_temp_init
            ;

/*
case @cpp_funbindexpr.kind of
  0 = @cpp_normal_call  // a normal call
| 1 = @cpp_virtual_call // a virtual call
| 2 = @cpp_adl_call     // a call whose target is only found by ADL
;
*/
cpp_iscall(unique int caller: @cpp_funbindexpr ref, int kind: int ref);

cpp_numtemplatearguments(
    unique int expr_id: @cpp_expr ref,
    int num: int ref
);

cpp_specialnamequalifyingelements(
    unique int id: @cpp_specialnamequalifyingelement,
    unique string name: string ref
);

@cpp_namequalifiableelement = @cpp_expr | @cpp_namequalifier;
@cpp_namequalifyingelement = @cpp_namespace
                       | @cpp_specialnamequalifyingelement
                       | @cpp_usertype;

cpp_namequalifiers(
    unique int id: @cpp_namequalifier,
    unique int qualifiableelement: @cpp_namequalifiableelement ref,
    int qualifyingelement: @cpp_namequalifyingelement ref,
    int location: @cpp_location_default ref
);

cpp_varbind(
    int expr: @cpp_varbindexpr ref,
    int var: @cpp_accessible ref
);

cpp_funbind(
    int expr: @cpp_funbindexpr ref,
    int fun: @cpp_function ref
);

@cpp_any_new_expr = @cpp_new_expr
              | @cpp_new_array_expr;

@cpp_new_or_delete_expr = @cpp_any_new_expr
                    | @cpp_delete_expr
                    | @cpp_delete_array_expr;

@cpp_prefix_crement_expr = @cpp_preincrexpr | @cpp_predecrexpr;

@cpp_postfix_crement_expr = @cpp_postincrexpr | @cpp_postdecrexpr;

@cpp_increment_expr = @cpp_preincrexpr | @cpp_postincrexpr;

@cpp_decrement_expr = @cpp_predecrexpr | @cpp_postdecrexpr;

@cpp_crement_expr = @cpp_increment_expr | @cpp_decrement_expr;

@cpp_un_arith_op_expr = @cpp_arithnegexpr
                  | @cpp_unaryplusexpr
                  | @cpp_conjugation
                  | @cpp_realpartexpr
                  | @cpp_imagpartexpr
                  | @cpp_crement_expr
                  ;

@cpp_un_bitwise_op_expr = @cpp_complementexpr;

@cpp_un_log_op_expr = @cpp_notexpr;

@cpp_un_op_expr = @cpp_address_of
            | @cpp_indirect
            | @cpp_un_arith_op_expr
            | @cpp_un_bitwise_op_expr
            | @cpp_builtinaddressof
            | @cpp_vec_fill
            | @cpp_un_log_op_expr
            | @cpp_co_await
            | @cpp_co_yield
            ;

@cpp_bin_log_op_expr = @cpp_andlogicalexpr | @cpp_orlogicalexpr;

@cpp_cmp_op_expr = @cpp_eq_op_expr | @cpp_rel_op_expr;

@cpp_eq_op_expr = @cpp_eqexpr | @cpp_neexpr;

@cpp_rel_op_expr = @cpp_gtexpr
             | @cpp_ltexpr
             | @cpp_geexpr
             | @cpp_leexpr
             | @cpp_spaceshipexpr
             ;

@cpp_bin_bitwise_op_expr = @cpp_lshiftexpr
                     | @cpp_rshiftexpr
                     | @cpp_andexpr
                     | @cpp_orexpr
                     | @cpp_xorexpr
                     ;

@cpp_p_arith_op_expr = @cpp_paddexpr
                 | @cpp_psubexpr
                 | @cpp_pdiffexpr
                 ;

@cpp_bin_arith_op_expr = @cpp_addexpr
                   | @cpp_subexpr
                   | @cpp_mulexpr
                   | @cpp_divexpr
                   | @cpp_remexpr
                   | @cpp_jmulexpr
                   | @cpp_jdivexpr
                   | @cpp_fjaddexpr
                   | @cpp_jfaddexpr
                   | @cpp_fjsubexpr
                   | @cpp_jfsubexpr
                   | @cpp_minexpr
                   | @cpp_maxexpr
                   | @cpp_p_arith_op_expr
                   ;

@cpp_bin_op_expr = @cpp_bin_arith_op_expr
             | @cpp_bin_bitwise_op_expr
             | @cpp_cmp_op_expr
             | @cpp_bin_log_op_expr
             ;

@cpp_op_expr = @cpp_un_op_expr
         | @cpp_bin_op_expr
         | @cpp_assign_expr
         | @cpp_conditionalexpr
         ;

@cpp_assign_arith_expr = @cpp_assignaddexpr
                   | @cpp_assignsubexpr
                   | @cpp_assignmulexpr
                   | @cpp_assigndivexpr
                   | @cpp_assignremexpr
                   ;

@cpp_assign_bitwise_expr = @cpp_assignandexpr
                     | @cpp_assignorexpr
                     | @cpp_assignxorexpr
                     | @cpp_assignlshiftexpr
                     | @cpp_assignrshiftexpr
                     | @cpp_assignpaddexpr
                     | @cpp_assignpsubexpr
                     ;

@cpp_assign_op_expr = @cpp_assign_arith_expr | @cpp_assign_bitwise_expr

@cpp_assign_expr = @cpp_assignexpr | @cpp_assign_op_expr

/*
  case @cpp_allocator.form of
    0 = plain
  | 1 = alignment
  ;
*/

/**
 * The allocator function associated with a `new` or `new[]` expression.
 * The `form` column specified whether the allocation call contains an alignment
 * argument.
 */
cpp_expr_allocator(
    unique int expr: @cpp_any_new_expr ref,
    int func: @cpp_function ref,
    int form: int ref
);

/*
  case @cpp_deallocator.form of
    0 = plain
  | 1 = size
  | 2 = alignment
  | 3 = size_and_alignment
  ;
*/

/**
 * The deallocator function associated with a `delete`, `delete[]`, `new`, or
 * `new[]` expression. For a `new` or `new[]` expression, the deallocator is the
 * one used to free memory if the initialization throws an exception.
 * The `form` column specifies whether the deallocation call contains a size
 * argument, and alignment argument, or both.
 */
cpp_expr_deallocator(
    unique int expr: @cpp_new_or_delete_expr ref,
    int func: @cpp_function ref,
    int form: int ref
);

/**
 * Holds if the `@cpp_conditionalexpr` is of the two operand form
 * `guard ? : false`.
 */
cpp_expr_cond_two_operand(
    unique int cond: @cpp_conditionalexpr ref
);

/**
 * The guard of `@cpp_conditionalexpr` `guard ? true : false`
 */
cpp_expr_cond_guard(
    unique int cond: @cpp_conditionalexpr ref,
    int guard: @cpp_expr ref
);

/**
 * The expression used when the guard of `@cpp_conditionalexpr`
 * `guard ? true : false` holds. For the two operand form
 * `guard ?: false` consider using `expr_cond_guard` instead.
 */
cpp_expr_cond_true(
    unique int cond: @cpp_conditionalexpr ref,
    int true: @cpp_expr ref
);

/**
 * The expression used when the guard of `@cpp_conditionalexpr`
 * `guard ? true : false` does not hold.
 */
cpp_expr_cond_false(
    unique int cond: @cpp_conditionalexpr ref,
    int false: @cpp_expr ref
);

/** A string representation of the value. */
cpp_values(
    unique int id: @cpp_value,
    string str: string ref
);

/** The actual text in the source code for the value, if any. */
cpp_valuetext(
    unique int id: @cpp_value ref,
    string text: string ref
);

cpp_valuebind(
    int val: @cpp_value ref,
    unique int expr: @cpp_expr ref
);

cpp_fieldoffsets(
    unique int id: @cpp_variable ref,
    int byteoffset: int ref,
    int bitoffset: int ref
);

cpp_bitfield(
    unique int id: @cpp_variable ref,
    int bits: int ref,
    int declared_bits: int ref
);

/* TODO
cpp_memberprefix(
    int member: @cpp_expr ref,
    int prefix: @cpp_expr ref
);
*/

/*
   kind(1) = mbrcallexpr
   kind(2) = mbrptrcallexpr
   kind(3) = mbrptrmbrcallexpr
   kind(4) = ptrmbrptrmbrcallexpr
   kind(5) = mbrreadexpr // x.y
   kind(6) = mbrptrreadexpr // p->y
   kind(7) = mbrptrmbrreadexpr // x.*pm
   kind(8) = mbrptrmbrptrreadexpr // x->*pm
   kind(9) = staticmbrreadexpr // static x.y
   kind(10) = staticmbrptrreadexpr // static p->y
*/
/* TODO
cpp_memberaccess(
    int member: @cpp_expr ref,
    int kind: int ref
);
*/

cpp_initialisers(
    unique int init: @cpp_initialiser,
    int var: @cpp_accessible ref,
    unique int expr: @cpp_expr ref,
    int location: @cpp_location_expr ref
);

/**
 * An ancestor for the expression, for cases in which we cannot
 * otherwise find the expression's parent.
 */
cpp_expr_ancestor(
    int exp: @cpp_expr ref,
    int ancestor: @cpp_element ref
);

cpp_exprs(
    unique int id: @cpp_expr,
    int kind: int ref,
    int location: @cpp_location_expr ref
);

/*
  case @cpp_value.category of
    1 = prval
  | 2 = xval
  | 3 = lval
  ;
*/
cpp_expr_types(
    int id: @cpp_expr ref,
    int typeid: @cpp_type ref,
    int value_category: int ref
);

case @cpp_expr.kind of
    1 = @cpp_errorexpr
|   2 = @cpp_address_of // & AddressOfExpr
|   3 = @cpp_reference_to // ReferenceToExpr (implicit?)
|   4 = @cpp_indirect // * PointerDereferenceExpr
|   5 = @cpp_ref_indirect // ReferenceDereferenceExpr (implicit?)
// ...
|   8 = @cpp_array_to_pointer // (???)
|   9 = @cpp_vacuous_destructor_call // VacuousDestructorCall
// ...
|  11 = @cpp_assume // Microsoft
|  12 = @cpp_parexpr
|  13 = @cpp_arithnegexpr
|  14 = @cpp_unaryplusexpr
|  15 = @cpp_complementexpr
|  16 = @cpp_notexpr
|  17 = @cpp_conjugation // GNU ~ operator
|  18 = @cpp_realpartexpr // GNU __real
|  19 = @cpp_imagpartexpr // GNU __imag
|  20 = @cpp_postincrexpr
|  21 = @cpp_postdecrexpr
|  22 = @cpp_preincrexpr
|  23 = @cpp_predecrexpr
|  24 = @cpp_conditionalexpr
|  25 = @cpp_addexpr
|  26 = @cpp_subexpr
|  27 = @cpp_mulexpr
|  28 = @cpp_divexpr
|  29 = @cpp_remexpr
|  30 = @cpp_jmulexpr // C99 mul imaginary
|  31 = @cpp_jdivexpr // C99 div imaginary
|  32 = @cpp_fjaddexpr // C99 add real + imaginary
|  33 = @cpp_jfaddexpr // C99 add imaginary + real
|  34 = @cpp_fjsubexpr // C99 sub real - imaginary
|  35 = @cpp_jfsubexpr // C99 sub imaginary - real
|  36 = @cpp_paddexpr // pointer add (pointer + int or int + pointer)
|  37 = @cpp_psubexpr // pointer sub (pointer - integer)
|  38 = @cpp_pdiffexpr // difference between two pointers
|  39 = @cpp_lshiftexpr
|  40 = @cpp_rshiftexpr
|  41 = @cpp_andexpr
|  42 = @cpp_orexpr
|  43 = @cpp_xorexpr
|  44 = @cpp_eqexpr
|  45 = @cpp_neexpr
|  46 = @cpp_gtexpr
|  47 = @cpp_ltexpr
|  48 = @cpp_geexpr
|  49 = @cpp_leexpr
|  50 = @cpp_minexpr // GNU minimum
|  51 = @cpp_maxexpr // GNU maximum
|  52 = @cpp_assignexpr
|  53 = @cpp_assignaddexpr
|  54 = @cpp_assignsubexpr
|  55 = @cpp_assignmulexpr
|  56 = @cpp_assigndivexpr
|  57 = @cpp_assignremexpr
|  58 = @cpp_assignlshiftexpr
|  59 = @cpp_assignrshiftexpr
|  60 = @cpp_assignandexpr
|  61 = @cpp_assignorexpr
|  62 = @cpp_assignxorexpr
|  63 = @cpp_assignpaddexpr // assign pointer add
|  64 = @cpp_assignpsubexpr // assign pointer sub
|  65 = @cpp_andlogicalexpr
|  66 = @cpp_orlogicalexpr
|  67 = @cpp_commaexpr
|  68 = @cpp_subscriptexpr // access to member of an array, e.g., a[5]
// ...  69 @cpp_objc_subscriptexpr deprecated
// ...  70 @cpp_cmdaccess deprecated
// ...
|  73 = @cpp_virtfunptrexpr
|  74 = @cpp_callexpr
// ...  75 @cpp_msgexpr_normal deprecated
// ...  76 @cpp_msgexpr_super deprecated
// ...  77 @cpp_atselectorexpr deprecated
// ...  78 @cpp_atprotocolexpr deprecated
|  79 = @cpp_vastartexpr
|  80 = @cpp_vaargexpr
|  81 = @cpp_vaendexpr
|  82 = @cpp_vacopyexpr
// ...  83 @cpp_atencodeexpr deprecated
|  84 = @cpp_varaccess
|  85 = @cpp_thisaccess
// ...  86 @cpp_objc_box_expr deprecated
|  87 = @cpp_new_expr
|  88 = @cpp_delete_expr
|  89 = @cpp_throw_expr
|  90 = @cpp_condition_decl // a variable declared in a condition, e.g., if(int x = y > 2)
|  91 = @cpp_braced_init_list
|  92 = @cpp_type_id
|  93 = @cpp_runtime_sizeof
|  94 = @cpp_runtime_alignof
|  95 = @cpp_sizeof_pack
|  96 = @cpp_expr_stmt // GNU extension
|  97 = @cpp_routineexpr
|  98 = @cpp_type_operand // used to access a type in certain contexts (haven't found any examples yet....)
|  99 = @cpp_offsetofexpr // offsetof ::= type and field
| 100 = @cpp_hasassignexpr // __has_assign ::= type
| 101 = @cpp_hascopyexpr // __has_copy ::= type
| 102 = @cpp_hasnothrowassign // __has_nothrow_assign ::= type
| 103 = @cpp_hasnothrowconstr // __has_nothrow_constructor ::= type
| 104 = @cpp_hasnothrowcopy // __has_nothrow_copy ::= type
| 105 = @cpp_hastrivialassign // __has_trivial_assign ::= type
| 106 = @cpp_hastrivialconstr // __has_trivial_constructor ::= type
| 107 = @cpp_hastrivialcopy // __has_trivial_copy ::= type
| 108 = @cpp_hasuserdestr // __has_user_destructor ::= type
| 109 = @cpp_hasvirtualdestr // __has_virtual_destructor ::= type
| 110 = @cpp_isabstractexpr // __is_abstract ::= type
| 111 = @cpp_isbaseofexpr // __is_base_of ::= type type
| 112 = @cpp_isclassexpr // __is_class ::= type
| 113 = @cpp_isconvtoexpr // __is_convertible_to ::= type type
| 114 = @cpp_isemptyexpr // __is_empty ::= type
| 115 = @cpp_isenumexpr // __is_enum ::= type
| 116 = @cpp_ispodexpr // __is_pod ::= type
| 117 = @cpp_ispolyexpr // __is_polymorphic ::= type
| 118 = @cpp_isunionexpr // __is_union ::= type
| 119 = @cpp_typescompexpr // GNU __builtin_types_compatible ::= type type
| 120 = @cpp_intaddrexpr // EDG internal builtin, used to implement offsetof
// ...
| 122 = @cpp_hastrivialdestructor // __has_trivial_destructor ::= type
| 123 = @cpp_literal
| 124 = @cpp_uuidof
| 127 = @cpp_aggregateliteral
| 128 = @cpp_delete_array_expr
| 129 = @cpp_new_array_expr
// ... 130 @cpp_objc_array_literal deprecated
// ... 131 @cpp_objc_dictionary_literal deprecated
| 132 = @cpp_foldexpr
// ...
| 200 = @cpp_ctordirectinit
| 201 = @cpp_ctorvirtualinit
| 202 = @cpp_ctorfieldinit
| 203 = @cpp_ctordelegatinginit
| 204 = @cpp_dtordirectdestruct
| 205 = @cpp_dtorvirtualdestruct
| 206 = @cpp_dtorfielddestruct
// ...
| 210 = @cpp_static_cast
| 211 = @cpp_reinterpret_cast
| 212 = @cpp_const_cast
| 213 = @cpp_dynamic_cast
| 214 = @cpp_c_style_cast
| 215 = @cpp_lambdaexpr
| 216 = @cpp_param_ref
| 217 = @cpp_noopexpr
// ...
| 294 = @cpp_istriviallyconstructibleexpr
| 295 = @cpp_isdestructibleexpr
| 296 = @cpp_isnothrowdestructibleexpr
| 297 = @cpp_istriviallydestructibleexpr
| 298 = @cpp_istriviallyassignableexpr
| 299 = @cpp_isnothrowassignableexpr
| 300 = @cpp_istrivialexpr
| 301 = @cpp_isstandardlayoutexpr
| 302 = @cpp_istriviallycopyableexpr
| 303 = @cpp_isliteraltypeexpr
| 304 = @cpp_hastrivialmoveconstructorexpr
| 305 = @cpp_hastrivialmoveassignexpr
| 306 = @cpp_hasnothrowmoveassignexpr
| 307 = @cpp_isconstructibleexpr
| 308 = @cpp_isnothrowconstructibleexpr
| 309 = @cpp_hasfinalizerexpr
| 310 = @cpp_isdelegateexpr
| 311 = @cpp_isinterfaceclassexpr
| 312 = @cpp_isrefarrayexpr
| 313 = @cpp_isrefclassexpr
| 314 = @cpp_issealedexpr
| 315 = @cpp_issimplevalueclassexpr
| 316 = @cpp_isvalueclassexpr
| 317 = @cpp_isfinalexpr
| 319 = @cpp_noexceptexpr
| 320 = @cpp_builtinshufflevector
| 321 = @cpp_builtinchooseexpr
| 322 = @cpp_builtinaddressof
| 323 = @cpp_vec_fill
| 324 = @cpp_builtinconvertvector
| 325 = @cpp_builtincomplex
| 326 = @cpp_spaceshipexpr
| 327 = @cpp_co_await
| 328 = @cpp_co_yield
| 329 = @cpp_temp_init
;

@cpp_var_args_expr = @cpp_vastartexpr
               | @cpp_vaendexpr
               | @cpp_vaargexpr
               | @cpp_vacopyexpr
               ;

@cpp_builtin_op = @cpp_var_args_expr
            | @cpp_noopexpr
            | @cpp_offsetofexpr
            | @cpp_intaddrexpr
            | @cpp_hasassignexpr
            | @cpp_hascopyexpr
            | @cpp_hasnothrowassign
            | @cpp_hasnothrowconstr
            | @cpp_hasnothrowcopy
            | @cpp_hastrivialassign
            | @cpp_hastrivialconstr
            | @cpp_hastrivialcopy
            | @cpp_hastrivialdestructor
            | @cpp_hasuserdestr
            | @cpp_hasvirtualdestr
            | @cpp_isabstractexpr
            | @cpp_isbaseofexpr
            | @cpp_isclassexpr
            | @cpp_isconvtoexpr
            | @cpp_isemptyexpr
            | @cpp_isenumexpr
            | @cpp_ispodexpr
            | @cpp_ispolyexpr
            | @cpp_isunionexpr
            | @cpp_typescompexpr
            | @cpp_builtinshufflevector
            | @cpp_builtinconvertvector
            | @cpp_builtinaddressof
            | @cpp_istriviallyconstructibleexpr
            | @cpp_isdestructibleexpr
            | @cpp_isnothrowdestructibleexpr
            | @cpp_istriviallydestructibleexpr
            | @cpp_istriviallyassignableexpr
            | @cpp_isnothrowassignableexpr
            | @cpp_isstandardlayoutexpr
            | @cpp_istriviallycopyableexpr
            | @cpp_isliteraltypeexpr
            | @cpp_hastrivialmoveconstructorexpr
            | @cpp_hastrivialmoveassignexpr
            | @cpp_hasnothrowmoveassignexpr
            | @cpp_isconstructibleexpr
            | @cpp_isnothrowconstructibleexpr
            | @cpp_hasfinalizerexpr
            | @cpp_isdelegateexpr
            | @cpp_isinterfaceclassexpr
            | @cpp_isrefarrayexpr
            | @cpp_isrefclassexpr
            | @cpp_issealedexpr
            | @cpp_issimplevalueclassexpr
            | @cpp_isvalueclassexpr
            | @cpp_isfinalexpr
            | @cpp_builtinchooseexpr
            | @cpp_builtincomplex
            ;

cpp_new_allocated_type(
    unique int expr: @cpp_new_expr ref,
    int type_id: @cpp_type ref
);

cpp_new_array_allocated_type(
    unique int expr: @cpp_new_array_expr ref,
    int type_id: @cpp_type ref
);

/**
 * The field being initialized by an initializer expression within an aggregate
 * initializer for a class/struct/union.
 */
#keyset[aggregate, field]
cpp_aggregate_field_init(
    int aggregate: @cpp_aggregateliteral ref,
    int initializer: @cpp_expr ref,
    int field: @cpp_membervariable ref
);

/**
 * The index of the element being initialized by an initializer expression
 * within an aggregate initializer for an array.
 */
#keyset[aggregate, element_index]
cpp_aggregate_array_init(
    int aggregate: @cpp_aggregateliteral ref,
    int initializer: @cpp_expr ref,
    int element_index: int ref
);

@cpp_ctorinit = @cpp_ctordirectinit
          | @cpp_ctorvirtualinit
          | @cpp_ctorfieldinit
          | @cpp_ctordelegatinginit;
@cpp_dtordestruct = @cpp_dtordirectdestruct
              | @cpp_dtorvirtualdestruct
              | @cpp_dtorfielddestruct;


cpp_condition_decl_bind(
    unique int expr: @cpp_condition_decl ref,
    unique int decl: @cpp_declaration ref
);

cpp_typeid_bind(
    unique int expr: @cpp_type_id ref,
    int type_id: @cpp_type ref
);

cpp_uuidof_bind(
    unique int expr: @cpp_uuidof ref,
    int type_id: @cpp_type ref
);

@cpp_runtime_sizeof_or_alignof = @cpp_runtime_sizeof | @cpp_runtime_alignof;

cpp_sizeof_bind(
    unique int expr: @cpp_runtime_sizeof_or_alignof ref,
    int type_id: @cpp_type ref
);

cpp_code_block(
    unique int block: @cpp_literal ref,
    unique int routine: @cpp_function ref
);

cpp_lambdas(
    unique int expr: @cpp_lambdaexpr ref,
    string default_capture: string ref,
    boolean has_explicit_return_type: boolean ref
);

cpp_lambda_capture(
    unique int id: @cpp_lambdacapture,
    int lambda: @cpp_lambdaexpr ref,
    int index: int ref,
    int field: @cpp_membervariable ref,
    boolean captured_by_reference: boolean ref,
    boolean is_implicit: boolean ref,
    int location: @cpp_location_default ref
);

@cpp_funbindexpr = @cpp_routineexpr
             | @cpp_new_expr
             | @cpp_delete_expr
             | @cpp_delete_array_expr
             | @cpp_ctordirectinit
             | @cpp_ctorvirtualinit
             | @cpp_ctordelegatinginit
             | @cpp_dtordirectdestruct
             | @cpp_dtorvirtualdestruct;

@cpp_varbindexpr = @cpp_varaccess | @cpp_ctorfieldinit | @cpp_dtorfielddestruct;
@cpp_addressable = @cpp_function | @cpp_variable ;
@cpp_accessible = @cpp_addressable | @cpp_enumconstant ;

@cpp_access = @cpp_varaccess | @cpp_routineexpr ;

cpp_fold(
    int expr: @cpp_foldexpr ref,
    string operator: string ref,
    boolean is_left_fold: boolean ref
);

cpp_stmts(
    unique int id: @cpp_stmt,
    int kind: int ref,
    int location: @cpp_location_stmt ref
);

case @cpp_stmt.kind of
    1 = @cpp_stmt_expr
|   2 = @cpp_stmt_if
|   3 = @cpp_stmt_while
|   4 = @cpp_stmt_goto
|   5 = @cpp_stmt_label
|   6 = @cpp_stmt_return
|   7 = @cpp_stmt_block
|   8 = @cpp_stmt_end_test_while // do { ... } while ( ... )
|   9 = @cpp_stmt_for
|  10 = @cpp_stmt_switch_case
|  11 = @cpp_stmt_switch
|  13 = @cpp_stmt_asm // "asm" statement or the body of an asm function
|  15 = @cpp_stmt_try_block
|  16 = @cpp_stmt_microsoft_try // Microsoft
|  17 = @cpp_stmt_decl
|  18 = @cpp_stmt_set_vla_size // C99
|  19 = @cpp_stmt_vla_decl // C99
|  25 = @cpp_stmt_assigned_goto // GNU
|  26 = @cpp_stmt_empty
|  27 = @cpp_stmt_continue
|  28 = @cpp_stmt_break
|  29 = @cpp_stmt_range_based_for // C++11
// ...  30 @cpp_stmt_at_autoreleasepool_block deprecated
// ...  31 @cpp_stmt_objc_for_in deprecated
// ...  32 @cpp_stmt_at_synchronized deprecated
|  33 = @cpp_stmt_handler
// ...  34 @cpp_stmt_finally_end deprecated
|  35 = @cpp_stmt_constexpr_if
|  37 = @cpp_stmt_co_return
;

cpp_type_vla(
    int type_id: @cpp_type ref,
    int decl: @cpp_stmt_vla_decl ref
);

cpp_variable_vla(
    int var: @cpp_variable ref,
    int decl: @cpp_stmt_vla_decl ref
);

cpp_if_then(
    unique int if_stmt: @cpp_stmt_if ref,
    int then_id: @cpp_stmt ref
);

cpp_if_else(
    unique int if_stmt: @cpp_stmt_if ref,
    int else_id: @cpp_stmt ref
);

cpp_constexpr_if_then(
    unique int constexpr_if_stmt: @cpp_stmt_constexpr_if ref,
    int then_id: @cpp_stmt ref
);

cpp_constexpr_if_else(
    unique int constexpr_if_stmt: @cpp_stmt_constexpr_if ref,
    int else_id: @cpp_stmt ref
);

cpp_while_body(
    unique int while_stmt: @cpp_stmt_while ref,
    int body_id: @cpp_stmt ref
);

cpp_do_body(
    unique int do_stmt: @cpp_stmt_end_test_while ref,
    int body_id: @cpp_stmt ref
);

#keyset[switch_stmt, index]
cpp_switch_case(
    int switch_stmt: @cpp_stmt_switch ref,
    int index: int ref,
    int case_id: @cpp_stmt_switch_case ref
);

cpp_switch_body(
    unique int switch_stmt: @cpp_stmt_switch ref,
    int body_id: @cpp_stmt ref
);

cpp_for_initialization(
    unique int for_stmt: @cpp_stmt_for ref,
    int init_id: @cpp_stmt ref
);

cpp_for_condition(
    unique int for_stmt: @cpp_stmt_for ref,
    int condition_id: @cpp_expr ref
);

cpp_for_update(
    unique int for_stmt: @cpp_stmt_for ref,
    int update_id: @cpp_expr ref
);

cpp_for_body(
    unique int for_stmt: @cpp_stmt_for ref,
    int body_id: @cpp_stmt ref
);

@cpp_stmtparent = @cpp_stmt | @cpp_expr_stmt ;
cpp_stmtparents(
    unique int id: @cpp_stmt ref,
    int index: int ref,
    int parent: @cpp_stmtparent ref
);

cpp_ishandler(unique int block: @cpp_stmt_block ref);

@cpp_cfgnode = @cpp_stmt | @cpp_expr | @cpp_function | @cpp_initialiser ;

cpp_stmt_decl_bind(
    int stmt: @cpp_stmt_decl ref,
    int num: int ref,
    int decl: @cpp_declaration ref
);

cpp_stmt_decl_entry_bind(
    int stmt: @cpp_stmt_decl ref,
    int num: int ref,
    int decl_entry: @cpp_element ref
);

@cpp_functionorblock = @cpp_function | @cpp_stmt_block;

cpp_blockscope(
    unique int block: @cpp_stmt_block ref,
    int enclosing: @cpp_functionorblock ref
);

@cpp_jump = @cpp_stmt_goto | @cpp_stmt_break | @cpp_stmt_continue;

@cpp_jumporlabel = @cpp_jump | @cpp_stmt_label | @cpp_literal;

cpp_jumpinfo(
    unique int id: @cpp_jumporlabel ref,
    string str: string ref,
    int target: @cpp_stmt ref
);

cpp_preprocdirects(
    unique int id: @cpp_preprocdirect,
    int kind: int ref,
    int location: @cpp_location_default ref
);
case @cpp_preprocdirect.kind of
   0 = @cpp_ppd_if
|  1 = @cpp_ppd_ifdef
|  2 = @cpp_ppd_ifndef
|  3 = @cpp_ppd_elif
|  4 = @cpp_ppd_else
|  5 = @cpp_ppd_endif
|  6 = @cpp_ppd_plain_include
|  7 = @cpp_ppd_define
|  8 = @cpp_ppd_undef
|  9 = @cpp_ppd_line
| 10 = @cpp_ppd_error
| 11 = @cpp_ppd_pragma
| 12 = @cpp_ppd_objc_import
| 13 = @cpp_ppd_include_next
| 18 = @cpp_ppd_warning
;

@cpp_ppd_include = @cpp_ppd_plain_include | @cpp_ppd_objc_import | @cpp_ppd_include_next;

@cpp_ppd_branch = @cpp_ppd_if | @cpp_ppd_ifdef | @cpp_ppd_ifndef | @cpp_ppd_elif;

cpp_preprocpair(
    int begin : @cpp_ppd_branch ref,
    int elseelifend : @cpp_preprocdirect ref
);

cpp_preproctrue(int branch : @cpp_ppd_branch ref);
cpp_preprocfalse(int branch : @cpp_ppd_branch ref);

cpp_preproctext(
    unique int id: @cpp_preprocdirect ref,
    string head: string ref,
    string body: string ref
);

cpp_includes(
    unique int id: @cpp_ppd_include ref,
    int included: @cpp_file ref
);

cpp_link_targets(
    unique int id: @cpp_link_target,
    int binary: @cpp_file ref
);

cpp_link_parent(
    int element : @cpp_element ref,
    int link_target : @cpp_link_target ref
);

/* XML Files */

cpp_xmlEncoding(unique int id: @cpp_file ref, string encoding: string ref);

cpp_xmlDTDs(
    unique int id: @cpp_xmldtd,
    string root: string ref,
    string publicId: string ref,
    string systemId: string ref,
    int fileid: @cpp_file ref
);

cpp_xmlElements(
    unique int id: @cpp_xmlelement,
    string name: string ref,
    int parentid: @cpp_xmlparent ref,
    int idx: int ref,
    int fileid: @cpp_file ref
);

cpp_xmlAttrs(
    unique int id: @cpp_xmlattribute,
    int elementid: @cpp_xmlelement ref,
    string name: string ref,
    string value: string ref,
    int idx: int ref,
    int fileid: @cpp_file ref
);

cpp_xmlNs(
    int id: @cpp_xmlnamespace,
    string prefixName: string ref,
    string URI: string ref,
    int fileid: @cpp_file ref
);

cpp_xmlHasNs(
    int elementId: @cpp_xmlnamespaceable ref,
    int nsId: @cpp_xmlnamespace ref,
    int fileid: @cpp_file ref
);

cpp_xmlComments(
    unique int id: @cpp_xmlcomment,
    string text: string ref,
    int parentid: @cpp_xmlparent ref,
    int fileid: @cpp_file ref
);

cpp_xmlChars(
    unique int id: @cpp_xmlcharacters,
    string text: string ref,
    int parentid: @cpp_xmlparent ref,
    int idx: int ref,
    int isCDATA: int ref,
    int fileid: @cpp_file ref
);

@cpp_xmlparent = @cpp_file | @cpp_xmlelement;
@cpp_xmlnamespaceable = @cpp_xmlelement | @cpp_xmlattribute;

cpp_xmllocations(
    int xmlElement: @cpp_xmllocatable ref,
    int location: @cpp_location_default ref
);

@cpp_xmllocatable = @cpp_xmlcharacters
              | @cpp_xmlelement
              | @cpp_xmlcomment
              | @cpp_xmlattribute
              | @cpp_xmldtd
              | @cpp_file
              | @cpp_xmlnamespace;

\section{Related Work}\label{sec:related}
%We propose the declarative-style static analysis of multilingual programs and
%actualize our approach as the JNI dataflow analyzer.
%We describe three closely related categories of work below.
\subsection{Static analysis for JNI programs}
%Among various language representations of JNI programs, studies dealing with
%pairs of languages are most closed related.  
%For JNI programs consisting of Java and C source codes, ILEA~\cite{ILEA}
%extends the Java Virtual Machine Language (JVML) and
%Jlint\footnote{\url{http://artho.com/jlint/manual.html}}, which is a JVML
%dataflow analyzer, to integrate C codes into one language.  Since a modest
%extension of JVML cannot fully support C semantics like memory models, it
%extremely over-approximates C operations such as read and write through
%pointers.  Lee et al.~\cite{LeeASE20} proposed a general approach to analyze
%multilingual programs in the form of host and guest languages.  Their approach
%first analyzes a guest language (C, in their implementation) to extract
%semantic summaries (by Infer\footnote{\url{https://fbinfer.com/}}), translates
%and integrates the summaries into a host language (Java), and then utilizes
%host language analyzer (Flowdroid~\cite{Flowdroid}).  While their approach can
%leverage the full features of existing static analyzers, ours inherits the
%query-based analysis and can compute target properties effectively without
%expensive and redundant summary generation.

For JNI programs consisting of Java and C source code, ILEA~\cite{ILEA} extends
the Java Virtual Machine Language (JVML) and
Jlint\footnote{\url{http://artho.com/jlint/manual.html}}, a dataflow analyzer
for Java bytecode, to compile both Java and C code to the extended JVML and
analyze the integrated programs.  Since the modest extension of JVML cannot
fully support C semantics like the C memory model, it extremely
over-approximates C operations such as read and write through pointers.  Lee et
al.~\cite{LeeASE20} proposed a general approach to analyze multilingual
programs written in both {\it host} and {\it guest} languages.  Their approach
first uses a guest language analyzer to extract semantics summaries from parts
written in the guest language, C in their implementation, translates and
integrates the summaries into a host language, Java, and then performs the
whole-program analysis using a host language analyzer.  While their approach
leverages the full features of existing static analyzers, ours inherits the
query-based analysis and can compute target properties effectively without
expensive and redundant summary generation.

Other studies deal with binaries rather than C/C++ source code.  Fourtounis et
al.~\cite{scanning} proposed a lightweight reverse engineering technique to
recover Java method calls from binaries instead of performing heavy analyses on
binary code.  Their reverse engineering generates datafacts of Java method
calls from binaries, which can be used in further declarative style Java
analyses. While the approach is lightweight but targets only Java method call
identification in binaries, our approach analyzes dataflows across language
boundaries between Java and C seamlessly.  JN-SAF~\cite{JN-SAF} defines a
unified dataflow summary to represent dataflows in both Java bytecode and
binary.  It extracts summaries from each Java method with a Java static
analyzer and from each native function with a binary symbolic execution, and
composes the summaries in a bottom-up manner to find data leakages over
language boundaries.  It sacrifices performance to analyze every possible
dataflow from binaries using the expensive symbolic execution. On contrary, our
approach is scalable in that the query-based approach analyzes only necessary
dataflows when C source code is available.


\subsection{Static Analysis for the other FFIs}
Android applications have another FFI between Java and JavaScript to maximize
their portability.  Android hybrid apps use JavaScript code to be run on
multiple browsers and can communicate with native Java code.
HybriDroid~\cite{hybridroid} analyzes Java and JavaScript at the same time on
the top of the WALA framework~\cite{WALA} to detect programmer errors on interlanguage
communications and to track private data leakages.  Bae et al.~\cite{BaeICSE19}
tackled the expensive analysis of HybriDroid and proposed a light-weight type
system covering types of bug in HybriDroid.  However, their type system does not
cover tracking flows of private data.  Jin et al.~\cite{jin2014code} proposed a
static detection of code injection attacks from JavaScript to Java.  To avoid
expensive whole multilingual program analyses, they manually model APIs in the
PhoneGap\footnote{\url{https://cordova.apache.org/}} framework and apply a taint
analysis on JavaScript only.

Python supports the interoperability mechanism with C~\cite{PythonC}.
Developers often import performance-oriented C code to high-level Python code.
Very recent work~\cite{sas2021} proposed a Python-C analyzer by reusing each
analyzer in the Mopsa framework~\cite{Mopsa}.  Their target properties require
precise context-sensitive value analyses.  Our approach easily activates only
the required features of each analyzer for such target properties.

% furr2005 OCaml and C
Furr and Foster~\cite{furr2005, furr2008} proposed a multilingual type inference
system for the native OCaml with foreign C FFI.  No out-of-bounds accesses and
no type casting in the C code were their assumptions.

\subsection{Declarative-style analysis}
Declarative-style analysis alleviates challenges in crafting a static program
analyzer and thus Datalog~\cite{allen2015D, allen2015stagedD, alpuente2010D, doop, dawson1996D, naik2006D, reps1994D, smaragdakis2014D, whaley2005D} has become a dominant
DSL for static analysis~\cite{scholz2016}.
Bravenboer and Smaragdakis proposed the \doop framework~\cite{doop} using Datalog
that showed dramatic speedups for the Java points-to analysis.  They explain that
the modularity and declarativeness of Datalog rules are the keys to improve
performance~\cite{doopWorkshop}.  In addition, researchers have improved
analysis backends, declarative language engines~\cite{whaley2005D, hoder2011muz, souffle, madsen2016}.
Avgustinov et al.~\cite{ql2016} proposed QL, a declarative and object-oriented
query language to be compiled into Datalog and runs on a relational DB, and static
analyzers implemented QL which scale to millions of lines of code.
Our approach successfully inherits the fast and easy analysis of declarative-style
and emphasizes the benefits with the problem of multilingual program analysis.

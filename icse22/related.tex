\section{Related Work}
\paragraph{Analysis of Java and C for JNI}
Among various language representations of JNI programs, we describe studies
dealing with pairs of languages.
For JNI programs consisting of Java and C source codes, ILEA~\cite{ILEA} extends
the Java Virtual Machine Language (JVML) and Jlint\footnote{\url{http://artho.com/jlint/manual.html}}, which is a JVML dataflow
analyzer, to integrate C codes into one language.  Since a modest extension of
JVML cannot fully support C semantics like memory models, it extremely
over-approximates C operations such as read and write through pointers.
Lee et al.~\cite{LeeASE20} proposed a general approach to analyze multilingual
programs in the form of host and guest languages.  Their approach first analyzes
a guest language (C, in their implementation) to extract semantic summaries
(by Infer\footnote{\url{https://fbinfer.com/}}), translates and integrates the summaries into a host
language (Java), and then utilizes host language analyzer (Flowdroid~\cite{Flowdroid}).
While their approach can leverage the full features of existing static
analyzers, ours inherits the query-based-analysis and can compute target
properties effectively without expensive and redundant summary generation.

\paragraph{Analysis of Java and binary for JNI}
Other studies deal with binaries rather than C/C++.
Fourtounis et al.~\cite{scanning} proposed a lightweight reverse engineering
technique to recover Java method calls in binary codes instead of performing
heavy analyses on binary code.  Their reverse engineering generates the data
facts of the Java calls with declarative style analyses for Java.
Their technique is lightweight yet targeting on Java method signatures,
in contrast, our approach targets on two general declarative style analyses for
each language and their interoperations seamlessly.
JN-SAF~\cite{JN-SAF} defines a unified summary in order to handle Java bytecode
and binary at once.  It extracts the summaries for each method with a Java
bytecode dataflow analyzer and a binary symbolic execution and composes the
summaries in a bottom-up manner to detect security vulnerabilities.
It sacrifices propagating dataflow facts until a fixed point by breaking a cycle
in the call graph arbitrarily to mitigate expensive computations from the
dataflow analysis and symbolic execution.  Our approach is scalable
for the JNI dataflow analysis even without sacrificing fixed point computations
when C source code is available.

\paragraph{Analysis for the other FFIs}
Hybridroid
Python-C

\paragraph{Declarative style analysis}
Declarative analyzer
Doop
CodeQL


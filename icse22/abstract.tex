\begin{abstract}
Multilingual programs are written in different programming languages
taking advantage of their own language features and benefits.
While multilingual programs have been widely developed for various purposes,
they are more vulnerable to bugs and security issues than monolingual programs.
Because different languages have distinctive behaviors,
researchers have proposed to leverage existing static analyzers for
monolingual programs to analyze multilingual programs.
The approaches first analyze each part written in a single language
using its corresponding analyzer to generate its summary and then
perform \textit{a target analysis} to detect bugs and security vulnerabilities cross
language boundaries using the generated summaries.
While they can leverage the full features of existing static analyzers,
they often suffer from the analysis performance overhead.
Because existing static analyzers are general purpose, in the
sense that they support abstractions of all the language features,
they may waste their analysis time on the features that may not be
relevant to summary generation for the target analysis. 

In this paper, we propose a simple and effective declarative-style static
analysis for multilingual programs for the first time.
A declarative-style analysis expresses analysis information as {\it datafacts},
describes how to derive a datafact from another datafacts as {\it rules},
and performs a {\it query-based} analysis, which considers only relevant datafacts.
Our approach extracts syntactic datafacts from the parts written in different
languages separately and defines additional rules to describe the interaction
between different languages.  Because our approach works directly on datafacts
syntactically extracted from programs and inherits the query-based-analysis
feature from a declarative style analysis, it can effectively check target
properties in multilingual programs without expensive and redundant summary generation.
As a proof-of-concept, we implement a JNI program static analyzer
on top of CodeQL, which detects bugs and security vulnerabilities by tracking
dataflows over language boundaries between Java and C.
In our empirical evaluation, we show that the analyzer is {\it precise} in that it analyzes
dataflows with higher precision and is {\it scalable} in that it detects the
same types of bugs and security vulnerabilities 14x faster on average than the
state-of-the-art analyzers.
\end{abstract}

%The use of multilingual programs are growing, and the demand for the static
%analysis of multilingual programs is also growing correspondingly.  Since most
%existing static analyzers target one language, the static analysis of
%multilingual programs are done by either translating one language into another
%and applying static analyzer for the translated language, or combining two
%analyzers so that the two analyzer give output in unified format, and analysis
%is done with respect to the output.  In whichever approach, the problem
%is that the system consists of too many components which treat each others
%as blackbox, and each component communicates with each other through a fixed
%form of API. This restriction results in lacks of flexibility and extensibility of
%the implementation.
%
%In this paper, we suggest a novel methodology for implementing static analysis
%for multilingual program, which is using declarative style analysis, for the
%first time. In declarative style analysis, everything is expressed in terms of
%"data-facts" and "rules". The analysis result and the information required for
%calculating it is expressed in "data-facts", and how one can derive new
%data-facts from the known data-facts is expressed in "rules". This simple
%structure makes declarative style analysis more flexible and extensible,
%alleviating the innate problem of multilingual analysis.
%
%To show the practicality of our approach, we implemented dataflow analyzer for
%JNI programs, using CodeQL, and compared its performance in terms of
%scalability and precision with a state-of-the-art JNI analyzer. The experiment
%result shows that our implementation is x14 faster, and has ??\%p better
%precision. In addition, we implemented bug checkers on top of our analyzer, and
%we could find bugs in real-world JNI applications.

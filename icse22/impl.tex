\begin{figure}[t]
  \centering
  \vspace{2mm}
  \includegraphics[width=0.47\textwidth]{img/codeql}
  \caption{Overall structure of JN-QL}
  \label{fig:codeql}
\end{figure}

\section{Implementation}\label{sec:impl}
In this section, we present JN-QL, a prototype implementation of our
approach to a declarative static analysis for multilingual programs,
in the case of dataflow analysis for JNI programs using CodeQL~\cite{codeql}.

\subsection{CodeQL}
CodeQL is a static analysis engine that transforms source code
programs into databases, and performs analysis by evaluating queries
written in the declarative language called QL (Query Language).
In QL, one can define rules by defining ``predicates'' or ``classes.''
For example, the following QL code defines the predicate \codeql{isOneTwoThree}:
\begin{lstlisting}[style=codeql,xleftmargin=2.5em]
predicate isOneTwoThree(int n) {
  n = 1
  or
  n = 2
  or
  n = 3
}
\end{lstlisting}
and the following definition defines the class \codeql{OneTwoThree}:
\begin{lstlisting}[style=codeql,xleftmargin=2.5em]
class OneTwoThree extends int {
  OneTwoThree() { // characteristic predicate
    this = 1
    or
    this = 2
    or
    this = 3
  }
}
\end{lstlisting}
A class defines a set of elements that satisfy the predicate called
``\codeql{characteristic predicate}.''
For more information about QL, one can refer to \citet{ql2016}'s paper
or the official document~\cite{codeql}.

Figure~\ref{fig:codeql} presents the overall structure of JN-QL.
First, it generates databases for both languages, C\footnote{
Even though JN-QL analyzes JNI programs written in Java and both C and
C++, this paper refers to C only fore presentation brevity.} and
Java, and merges them to one database.  This corresponds
to the step of extracting syntactic datafacts from source code programs.
Then, we merge the common datafacts and rules in both languages,
which are parts of their libraries that CodeQL provides, into one merged library.
Finally, using the merged database and merged library, a user can write a query to
perform a client-analysis, and evaluate it to produce its analysis result.

\subsection{Creating Databases}
The first step is to generate database for each of two languages.  For
compiled languages such as C and Java, CodeQL generates database by running
the compiler for each language. While the compiler is running, CodeQL monitors
the behavior of compiler and extracts information it needs, and create database
with that information.  Creation of database for one language is performed in
two steps: first, the extracted information from compiler is stored in the
human readable file format called trap files, and second, these trap files are
then finalized into database, written in binary format.

\begin{lstlisting}[style=java,numbers=none,xleftmargin=2.5em]
//Example of trap file
#10017=@"class;hello.HelloJNI"
...
#10044=@"type;int"
primitives(#10044,"int")
...
#10061=@"callable;{#10017}.java_callback({#10044}){#10044}"
...
#10067=@"params;{#10061};0"
params(#10067,#10044,0,#10061,#10067)
paramName(#10067,"java_callback_param")
\end{lstlisting}

To create a database for two languages, JN-QL performs first step for
each languages separately to get two sets of trap files.  Next step would be to
perform finalization step on merged set of trap files. However, a problem is that
both of trap files have table with duplicated name, so simply merging them would not work.
The solution is to add prefix to name of each table. For example, if both
database have tables named "@expr", the table from C would be renamed as
"@cpp\_expr", and the table from Java would be renamed as "@java\_expr". After
renaming each table, the second step can be applied to finalize the database on
which the query can be evaluated.

\subsection{Lifting Libraries}
CodeQL provides various libraries for each languages, which consists of some
pre-defined predicates and classes that can be useful for user to implement
analysis on their own taste. Dataflow analysis library is one of them, and both
C and Java supports this dataflow analysis library. Two dataflow analysis
library have same framework: they share same classes such as "Node", and some
predicates such as "simpleLocalFlowStep".

\begin{lstlisting}[style=codeql,xleftmargin=2.5em]
// cpp/dataflow/internal/DataFlowUtil.qll
class Node extends TNode {
  ...
}
predicate simpleLocalFlowStep(Node nodeFrom, Node nodeTo) {
  // Expr -> Expr
  exprToExprStep_nocfg(
    nodeFrom.asExpr(),
    nodeTo.asExpr()
  )
  or
  // Assignment -> LValue post-update node
  ...
}
class Node extends TNode {
  ...
}
// java/dataflow/internal/DataFlowUtil.qll
predicate simpleLocalFlowStep(Node node1, Node node2) {
  // Variable flow steps through
  // adjacent def-use and use-use pairs.
  exists(SsaExplicitUpdate upd |
    upd.getDefiningExpr().(VariableAssign).getSource()
    = node1.asExpr() or
    upd.getDefiningExpr().(AssignOp) = node1.asExpr()
  |
    node2.asExpr() = upd.getAFirstUse()
  )
  or  // Flow through this
  ...
}
\end{lstlisting}
However, these two implementations are not compatible, that is, although they have the same name,
we can not use "Node" class of C as an argument for "simpleLocalFlowStep" predicate of Java or vice versa.
Therefore, we lift each of the library into the same level so that classes and predicates become compatible.
First, we encapsulated each of original dataflow into CodeQL's module, named CPP and JAVA so that
original classes and predicated can be distinguished with lifted ones.
A class can be lifted by first defining sum type, which denotes that the lifted class would be either from C or
Java, and then make the lifted class be of that type. We also implemented two member predicates that can cast
the lifted class into each of corresponding class.
\begin{lstlisting}[style=codeql,xleftmargin=2.5em]
private newtype TNode =
  TJavaNode(JAVA::Node n)
  or
  TCppNode(CPP::Node n)
class Node extends TNode {
  JAVA::Node asJava() {
    this = TJavaNode(result)
  }
  CPP::Node asCpp() {
    this = TCppNode(result)
  }
  ...
}
\end{lstlisting}

A predicate can be lifted by combining two original predicates with "or"
connectives.  For each original predicate, each of the arguments and return
values are casted down to corresponding language's class. After lifting, the
lifted predicate shows equivalent behavior as the original ones if all the
arguments are from the same language.
\begin{lstlisting}[style=codeql,xleftmargin=2.5em]
predicate simpleLocalFlowStep(Node node1, Node node2) {
  JAVA::simpleLocalFlowStep(
    node1.asJava(), node2.asJava()
  )
  or
  CPP::simpleLocalFlowStep(
    node1.asCpp(), node2.asCpp()
  )
}
\end{lstlisting}
\subsection{Merging Libraries}

After the library is lifted, the last step is to extend some predicates to
reflect the semantics of interoperation between languages. The interaction from
Java to C, or C to Java are identified, and some predicates are extended to
model their behaviors. As an concrete example, Let's take a look how the predicate
named viableCallable can be extended.
\begin{lstlisting}[style=codeql,xleftmargin=2.5em]
DataFlowCallable viableCallable(DataFlowCall c) {
result.asJava()
  = JAVA::viableCallable(c.asJava()) or
result.asCpp()
  = CPP::viableCallable(c.asCpp()) or
result.asCpp()
  = viableCallableJ2C(c.asJava()) or
result.asJava()
  = viableCallableC2J(c.asCpp())
}
\end{lstlisting}
The first two lines are result of lifting, and they take advantage of the
original predicates from dataflow library.  They handle the call edges from
Java to Java, and from C to C.

Next two lines are the result of merging library, and they are responsible for
inter-language call edges.  The predicate "viableCallableJ2C" finds call edges
from Java to C, and the predicate "viableCallableC2J" finds call edges from
C to Java. These two call edges have different characteristic, and they
are implemented in different way.

\textbf{Java to C} The interaction from Java to C is done by Java code
calling native function in C, possibly with some arguments. The function
call target is determined in static manner. The target function should
follow the JNI naming convention, which is adding "Java\_" as prefix, 
followed by fully qualified name of class and additional "\_", to the
method name. For example, the target function name for the method call
cfunction would be Java\_fully\_\_qualified\_\_class\_\_name\_cfunction.
Based on this convention, we can define the predicate viableCallableJ2C
so that f = viablaCallableJ2C(m) holds when f.toString() = "Java\_" + 
m.className() + "\_" + "m.toString() holds.

\textbf{C to Java} The interaction from C to Java is more complex, and
requires more detailed implementation. The biggest difference is that
the method call from C to Java requires the run-time value of variables.
First, C calls the interface function "GetMethodID(name, sig)" to get "method
ID" of the method whose name matches the first argument, and the type signature
matches the second argument passed to this function. This method id is stored
at a variable, say "mid", and actual method call is done by calling another
interface function, "Call<type>Method(obj, mid, args...)". Calling this interface
function corresponds to call the method that mid indicates, with the "this object" as
obj, and the arguments as args.

In order to correctly handle this method call, we have to answer these
questions: "what string values does 'name' or 'sig' have when GetMethodID is
called", and "what method ID value does 'mid' have when Call<type>Method is
called". Note that what we need to answer to this question is the dataflow
analysis. Although inter-language dataflow is needed to soundly answer to the
questions, in practice intra-language dataflow analysis is enough in most
situations. Therefore, we implemented two "inner-flow" analysis module for C,
which find all the dataflow from string literal to the argument of interface
function, and the dataflow from interface function call result to the argument
of interface function. Based on these two modules, we can implement the
predicate viableCallableC2J by connecting the call edge from "Call<type>Method"
call to the method m, if there is a flow to mid from call to "GetMethodID", and
string values that flow into name argument and sig argument of the "GetMethodID"
corresponds with that of method m.

Other than the predicate viableCallable, there are also other predicates that
are extended. Most of them are specialized "step" predicates, where the purpose
of extension is to consider other JNI interface functions, such as
findClass or GetFieldID. The extensions are done in similar as handling
call from C to Java mentioned above.

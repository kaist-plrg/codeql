\newcommand{\req}[1]{RQ#1}
\input{tableRQ1}

\section{Evaluation}\label{sec:eval}

To show the effectiveness of our approach, we evaluate our analyzer
JN-QL with the following three research questions:
\begin{itemize}
  \item \textbf{\req{1}: Feasibility.} Can \ours analyze JNI programs that use
    various JNI inteoperations?

  \item \textbf{\req{2}: Performance.} How precise and scalable is \ours for
    real-world JNI program analysis compared to JN-Sum~\cite{LeeASE20}?

  \item \textbf{\req{3}: Usefulness.} Can \ours analyze the same kinds of bugs
    the state-of-the-art JNI program analyzers can detect?
\end{itemize}

For \req{1}, we analyze the benchmarks in NativeFlowBench~\cite{nativeflowbench,
JN-SAF} using \ours. The benchmarks contain 23 JNI Android applications (apps) that
use various JNI interoperations and sensitive data leakage from {\it sources} to
{\it sinks} across language boundaries via the interoperations. We compare
the analysis results of \ours to the results of JN-Sum and JN-SAF. We use
compiled versions of the benchmarks for JN-SAF because it targets compiled JNI
programs and uses the source code of the benchmarks for \ours and JN-Sum.

For \req{2}, we compare the analysis results of \ours and JN-Sum on 42
real-world JNI Android apps downloaded from F-Droid, a repository of
open-source Android apps~\cite{fdroid}. We first classified
F-Droid apps into JNI and non-JNI apps. Then, we selected
all 42 apps that can be compiled without any errors as our analysis targets.

For \req{3}, we detect JNI interoperation bugs in the 42 real-world Android
apps using \ours. We implemented a checker detecting four kinds of
bugs on top of \ours using the query language of CodeQL. We chose our target
JNI interoperation bugs as the same as the targets of the client
analysis of the previous research~\cite{LeeASE20, ILEA}.


\subsection{\req{1}: Feasibility}
Table~\ref{table:RQ1} summarizes the analysis results of \ours, JN-Sum,
and \jnsaf on 23 benchmarks in NativeFlowBench.
The {\bf Benchmark} columns show the benchmark names,
{\bf Precision} show the analysis results of 
JN-Sum and \ours, and {\bf Dataflow} show the analysis results of JN-SAF and \ours.
JN-Sum and JN-SAF have different analysis purposes from
each other; JN-Sum constructs call graphs of JNI programs, and JN-SAF
detects data leakages from sources to sinks.  For fair comparison, we compare
\ours and JN-Sum for the precision of resolving targets of foreign
function calls, and compare \ours and JN-SAF for the data leakage detection results.
We marked each analysis result as a success ($\bigcirc$) or failure ($\times$).
In the precision comparison, an analysis succeeds if
it precisely resolves targets of all foreign function calls between Java and C, and it fails otherwise.
In the dataflow comparison, an analysis succeeds
if it reports all data leakages correctly without any false positives or negatives.


In the precision comparison, \ours successfully analyzed 21 out of 23
benchmarks, while JN-Sum failed in three more benchmarks than \ours.
We manually confirmed that the two failures both in \lees and \ours
come from built-in structs and functions in C; {\it
icc\_javatonative} stores Java class information in the Android built-in
struct {\tt android\_app} and {\it native\_complexdata\_stringop} generates
a Java field name by concatenating two string values via the {\tt strcat} built-in function.
  Because \ours and JN-Sum do not handle such built-in
structs and functions, they failed to analyze the two benchmarks.
  \lees failed to analyze three more benchmarks due to native entry points
of the benchmarks~\cite{nativeactivity}.
  FlowDroid~\cite{Flowdroid} used by JN-Sum performs a whole-program
analysis from Android entry points. 
  Because the benchmarks have entry points only in C differently from monolingual
Android apps, FlowDroid cannot find entries from which its analysis starts.
  Contrary to JN-Sum, \ours performs a query-based
analysis, which can resolve the targets of foreign function calls regardless of program entries.

\input{tableRQ2}

In the dataflow comparison, \ours found data leakages correctly in 20
benchmarks but reported false negatives for three benchmarks, while JN-SAF
analyzes 21 benchmarks correctly. 
{\it icc\_javatonative} and {\it icc\_nativetojava} leak data via the Android
inter-component communication that is beyond the scope of \ours.
The remaining two different failures of \ours and JN-SAF come from their array analysis policies.
{\it native\_leak\_array} stores sensitive data in an array, retrieves the data from the array,
and leaks it.  On the other hand, {\it native\_noleak\_array} stores sensitive
data in an array as well, but it retrieves another element from the array and uses it.
Because distinguishing different indices of an array is challenging, JN-SAF
tracks every value retrieved from an array if the array contains sensitive data.
Such over-approximation enables JN-SAF to analyze {\it
native\_leak\_array} correctly but introduces a false alarm for {\it
native\_noleak\_array}.  In contrast, because CodeQL does not
track dataflows depending on arrays by default, \ours does not report
a false alarm for {\it native\_noleak\_array} but cannot find the data leakage in {\it
native\_leak\_array}.


\subsection{RQ2: Performance}
Table~\ref{table:RQ2} shows analysis results of \ours on real-world Android
JNI apps. Out of 42 apps we analyzed, we summarize analysis
results of 25 apps that have interoperation from C to Java.\footnote{We
list the full analysis results up in our supplementary material.} The first
column denotes app names, the second to fourth columns denote database
creation time of C, Java, and their merged database respectively, the fifth
column denotes query processing time, and the sixth denotes total analysis time
include the database creation and query processing. The seventh to ninth and
the tenth to twelfth denote the number of C-to-Java function calls and
C-to-Java field accesses, respectively. The sub-columns {\bf \#Precise}, {\bf
\#Resolved}, and {\bf Total} represent the number of precisely resolved,
resolved, and total foreign function call-sites, respectively. We counted a
resolved call-site as precise, when our analysis finds a single target method
or field at the call-site.


\ours resolved 1076 out of 1171 (92\%) foreign function calls, including
347 out of 404 (86\%) C-to-Java method calls and 729 out of 767 (95\%)
C-to-Java field accesses. In addition, 1008 (86\%) resolved foreign function
calls are precies. The results show that \ours resolves more foreign
function calls even precisley than JN-Sum that \inred{...} on the same
dataset. \ours failed to resolve 95 (8\%) foreign function calls because
of complex language semantics such as arrays and function pointers. Because
CodeQL does not track dataflows depending on C function pointers as well as
arrays we descibed, \ours failed to analyze method or field IDs required
to resolve the foreign function calls.

\begin{figure}[t]
  \centering
  \vspace{2mm}
  \includegraphics[width=0.5\textwidth]{img/graph}
  \vspace*{-1.5em}
  \caption{Analysis time of \ours and ASE'20}
  \label{fig:graph}
\vspace*{-.5em}
\end{figure}

\ours is scalable even for large-scale programs as well. The analysis
time was 161.3 seconds on average for each app, including 103.8 seconds
for the DB creation and 57.5 seconds for the query processing. The DB creation
usually took more time than the query processing except for {\it Graph 89}, and
the DB creation time was almost linear to the size of code. \ours took
about 12 minutes at most to analyze {\it Tileless Map} having about one million
lines of code. Figure~\ref{fig:graph} visualizes analysis time of \ours
compared to JN-Sum. \inred{describe the comparison result...}  Note
that once we create database for a program, we can evaluate multiple queries on
it without re-creation to obtain various analysis results of the program.


\subsection{RQ3: Usefulness}
\input{tableRQ3}
The bug checker of \ours detects four kinds of JNI interoperation bugs
that previous research~\cite{ILEA, LeeASE20} defined as the follows:


\begin{itemize}
  \item {\it NullDereference}: dereferencing the {\tt null} value of Java in C
  \item {\it MissingFun}: calling a missing Java method from C
  \item {\it TypeMismatch}: declaring a C function with a different signature
    from its corresponding Java native method
  \item {\it WrongSignature}: calling a Java method using a method ID with a
    wrong signature in C
\end{itemize}


\begin{figure}[t]
  \centering
  \vspace{2mm}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=cpp,xleftmargin=2.5em]
//EmulatorActivity.java
String tmp = null;
String folder = Util.GetInternalAppStorage(activity);

if (folder != null) {
  tmp = folder + "tmp";
  Util.CreateDirectory(tmp);
}

EmulatorActivity.nativeInitGraph89(..., tmp);

//wrappercommonjni.c
void nativeInitGraph89(..., jstring tmp_dir) {
   (*env)->GetStringUTFChars(env, tmp_dir, 0);
   ...
}
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{NullDereference}
    \label{fig:bug1}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=cpp,xleftmargin=2.5em]
//JpegRedaction.java
package org.witness.obscuracam.photo.jpegredaction;

public class JpegRedaction {
  private native void redactRegions(...);
  ...
}

//JpegRedaction.cpp
void
Java_org_witness_securesmartcam_jpegredaction_ JpegRedaction_redactRegions(...) {
  ...
}
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{MissingFun}
    \label{fig:bug2}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=cpp,xleftmargin=2.5em]
//MuPdfPage.java
private native static List<PageTextBox> search(...);

//mupdfdroidbridge.c
jobjectArray search(...){
   ...
 }
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{TypeMismatch}
    \label{fig:bug3}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=cpp,xleftmargin=2.5em]
//PrBoomActivity.java
void OnMessage(String text);
void OnInfoMessage(String msg, int displayType);

//jni_doom.h
#define CB_CLASS_MSG_SIG  "(Ljava/lang/String;I)V"
#define CB_CLASS_INFMSG_SIG  "(Ljava/lang/String;I)V"

//jni_doom.c
mSendStr = (*env)->GetMethodID(env, jNativesCls, "OnMessage", CB_CLASS_MSG_SIG);

    \end{lstlisting}
    \vspace*{-.5em}
    \caption{WrongSignature}
    \label{fig:bug3}
  \end{subfigure}
  \vspace*{-.5em}
  \caption{Four kinds of JNI interoperation bugs}
  \label{fig:bugs}
\end{figure}

Table~\ref{table:RQ3} summarizes the bug detection results of 19 out of 42
apps, on which \ours reported true or false alarms.  The first
column denotes app names, the second and third columns denotes the
number of true and false positives of {\it NullDereference} respectively, and
the fourth to six columns denote the number of true positives of {\it
MissingFun}, {\it TypeMismatch}, and {\it WrongSig} respectively. We omit the
number of false positivies of the last three bug types, because \ours
reported only true positives on them. We classified the reported alarms into
true or false positives by manual inspection of source code. 


\ours found 33 genuine bugs, but reported 24 false positives in 19
apps. All false positives are reported only in the {\it
NullDereference} bug detection; \ours reported five true and 24 false alarms
of {\it NullDereference} in 11 apps, nine true alarms of {\it MissingFun} in
three apps, 17 true alarms of {\it TypeMismatch} in eight apps, and two true
alarms of {\it WrongSignature} in two apps. We manually checked that the false
positives come from diverse over-approximation issues in static analyses but
one of the main causes is conditionally sanitized variables.  Many apps
have a code pattern that assigns a value to a variable only if the variable has
the {\tt null} value. Because our analysis does not support the
path-sensitivity that analyzes each execution path separately, it reports that
the variable may still have {\tt null} even after the conditional assignment. 



Figure~\ref{fig:bugs} demonstrates four kinds of JNI interoperation bugs our
tool detected.  For brievity, we simplified code snippets excerpted from
real-world apps. 

Figure~\ref{fig:bugs}(a) shows a code fragment with the {\it NullDerefence} bug
in Graph 89. Java may calls a C function {\tt nativeInitGraph89} with {\tt
null} value as the last argument, because a Java variable {\tt tmp} has {\tt
null} when a function {\tt GetInternalAppStorage} returns {\tt null}.  The C
function calls a JNI function {\tt GetStringUTFChars} with the value as the
second argument, without null check of the value. However, because the JNI
specification describes that the second argument of the functions must not be
{\tt null}~\cite{getstringutfchars}, the JNI function may behave unexpectedly.
Note that calling JNI functions with wrong arguments may introduce various
unexpected executions, since JVMs do not validate the arguments because of the
performance overhead~\cite{hwang2021justgen}.

\renewcommand{\texttt}[1]{%
  \begingroup
  \ttfamily
  \begingroup\lccode`~=`/\lowercase{\endgroup\def~}{/\discretionary{}{}{}}%
  \begingroup\lccode`~=`[\lowercase{\endgroup\def~}{[\discretionary{}{}{}}%
  \begingroup\lccode`~=`.\lowercase{\endgroup\def~}{.\discretionary{}{}{}}%
  \catcode`/=\active\catcode`[=\active\catcode`.=\active
  \scantokens{#1\noexpand}%
  \endgroup
}

Figure~\ref{fig:bugs}(b) shows a code snippet with the {\it MissingFun} bug in
ObscuraCam. As described in Section~\ref{sec:merging}, JNI has a C function
naming convention for JVMs to link Java native methods to the corresponding C
functions. While a Java class {\tt JpegRedaction} declaring a native method
{\tt redactRegions} belongs to a package
\texttt{org.witness.obscuracam.photo.jpegredaction}, the corresponding C
function is named with a wrong package name
\texttt{org.witness.securesmartcam.jpegredaction}.  When calling the native
method, JVM fails to link the native method because of the wrongly named C
function.


Figure~\ref{fig:bugs}(c) shows a code snippet with the {\it TypeMismatch} bug
in Document Viewer.  While the return type of a Java native method {\tt search}
is {\tt List<PageTextBox>}, the return type of the corresponding C function
{\tt search} is {\tt jobjectArray} that corresponds to the Java built-in array
container. The return type mismatch does not have an effect on linking between
Java native methods and C functions. However, since it is a unspecified case in
JNI specification, interoperation via such native methods may behave
differently on different JVMs~\cite{LeeASE20}. 


Figure~\ref{fig:bugs}(d) shows a code fragment with the {\it WrongSignature}
bug in PrBoom. C tries to get an ID of a Java method {\tt OnMessage} with a
signature \texttt{(LJava/lang/String;I)V}, but the Java method has a different
signature \texttt{(LJava/lang/String;)V} taking sole String parameter. Because
the two signatures are not equal to each other, C always obtains {\tt null}
value instead of an ID and a Java exception is thrown in this example. In
addition, it may introduce errors in subsequent instructions when using the
return value without null check or calling JNI functions without handling the
thrown Java exception~\cite{jniexcept}.

\section{Introduction}

There are many cases where a single language alone is not enough to meet the
requirement of large and comlplex programs nowadays, and using multiple
languages is one of the promising way to implement such programs. For this
reason, many languages support FFI(Foreign function interface), which enables a
program written in a language to call the function written in another language.
For example, (Write examples of FFI here)

However, writing a relialbe multilingual program is not an easy task. The
programmer of multilingual programs should fully understand semantics of both
language, in addition to the inter-operation semantics between two languages in
order to write the correct code.  Such complex semantics make it much more
difficult to reson about the program, and programmers may leave some bugs that
can crash the program in runtime, or security vulnerabilities that attackers
can take advantage of.

Performing static analysis on multilingual programs can help developers to
write more reliable code. (Write importance of static analysis here.)

For this reason, previous researchers have tried to implement the analyzer for
multilingual analysis with various approaches.  One approach[1][2] is
translation-based approach, where one language is translated or compiled into
another language and analysis on translated language is performed with existing
analyzer.  This approach has a virtue in that existing analyzers for tranalated
language can be reused with almost no modification.  However, since translating
one language into another one while preserving every semantics is a challenging
task, the translation is usually performed in abstract manner to approximate
the effect of original code might have, and translated code is composed of the
subset of the target langague. Another approach[3] is combination-based
approach, which is to modify and combine existing analyzers of each language,
so that two analyzers give the analysis result in unified output format, and
the analysis is performed with respect to this output format.

A common, inevitable pattern of implementing analyzer for multilingual program
is that, due to the nature of multilingual programs being composed of multiple
language, the analyzer itself also consists of multiple components. The problem
of the previous approaches is that each of the component treats other
components as blackbox. The detailed implementation of a component is not
visible to another component, and the only way one component can interact with
each other is through a fixed form of API. For example, in translation-based
approach, the translator and the client-analyzer can only communicate through a
syntax of target language, and in combination-based approach, two analyzers
communicate via unified output format. This makes the implementation
restrictive and inflexible. Modifying one component requires that it still
meets the API requirement after the modification. Otherwise, modification to
multiple components should be made simultaneously, which can be imposes extra
burden on analyzer developers, especially if each component is very different
from each other. For example, we can consider a situation where one wants to
extend the client-analysis so that it performs more accurate analysis. If the
current API does not contain enough information, then it might be impossible to
implement such a extended anlysis that the developer is thinking of. Then it is
required that API is extended and the other components pass such information
via API, which requries more work for the developer.

In this paper, we suggest a novel methodology for implementing static analysis
of multilingual program, which is using declarative language.  In declarative
language, everything is expressed as in terms of "data-fact" and "rule".
"Data-fact" is simply an ordered tuples of elements, and "rule" is a way to
define how one data-fact can be derived from other data-facts. Evaluating
declarative program is defined as finding all possible data-facts that can be
derived by given basic data-facts and rules.  Adopting this approach, we can
perform static analysis on multilingual programs in following sense.  The first
step is to converted each language into a set of syntactic data-facts.
Programmers can define the intra-language rules that would generate new
data-facts based on already known data-facts. New data-facts generated in this
way would tend to contain more higer-level information, considering the
semantics of each languge. Finally, programmer can implement the static
analysis by defining the inter-language rules considering the inter-operation
semantcis between two languages, and evaluating these new rules along with
intra-language rules would give the final analysis result in form of a set of
data-facts.

On top of the know advantages of enabling fast, modular and scalable
implementation[4], using declarative language can also be helpful to alleviate
the problems of multilingual analysis mentioned above. The main reason is that
in declarative style, any rule can easily utilze the data-facts generated by
any component, that is, no fixed API is needed between two components.  This
feature lessens the burden of modifying or extending the existing analyzer.
The additionaly required task is boiled down to defining some more rules and
data-facts for different components, which does not impose significant overhead
than implementing the analyzer itself.

To show the practicality of our approach, we chose JNI programs as analysis
target, and implemented dataflow analysis as client-analysis using CodeQL[5], a
static analysis where implementation can be written in declarative style. We
applied our analyzer to real-world android JNI applications retrieved from
F-droid[6], a repository for open-source android applications to see whether
performance of this implementation is competable with existing works.
Surprisingly, our experiment result show that our implementation outperforms
the state of the art JNI analyzer in terms of speed and analyzer our
implementation shows x14 speed up on average, and shoinwg the slightly better
precision. In addition, we could emulate the various kinds of bug detectors
mentioned in previous researches on top of our analyzer in declarative style
with relative ease, and could find the genuine bugs and vulnerabilites from the
benchmark.

The contribution of this paper is as follows:

+ We suggested a new methodology of using declarative style static analysis
for multilingual program, which is more flexible and extensible.

+ We implemented JNI dataflow analyzer with CodeQL based on declarative-style approach,
which outperforms state-of-art analyzers in terms of scalability and precision.

+ We could find new bugs and vulnerabilities from the real-world JNI applications
by easily implementing the bug detectors from the previous researches.

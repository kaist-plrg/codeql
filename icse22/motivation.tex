\section{Motivation}
In this section, we show how multilanguage interactions work using a
simple example code, and explain the main challenge that is difficult to handle
by the previous approaches but our declarative-style analysis can handle.

\begin{figure}[t]
  \centering
  \vspace{2mm}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=java,xleftmargin=2.5em]
public void main() {
  Node node = null;
  B::f(node);
}
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{Method in language A calling a function in language B}
    \label{fig:exam1:langA}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=cpp,firstnumber=5,xleftmargin=2.5em]
void f(Node* param) {
  if(param != NULL) {
    Node* ptr = param;
    ptr->next = new Node;
  }
}
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{Function in language B receiving null from language A}
    \label{fig:exam1:langB}
  \end{subfigure}
  \vspace*{-.5em}
  \caption{Multilingual code in language A and language B}
  \label{fig:exam1}
\end{figure}

\begin{figure}[t]
  \centering
  \vspace{2mm}
  \begin{lstlisting}[style=cpp,firstnumber=5,xleftmargin=2.5em]
void f(Node* param) {
  Node* ptr = param;
  Node* next;
  if(condition()) {
    next = NULL;
  } else {
    next = new Node;
  }
  ptr->next = next;
}
  \end{lstlisting}
  \vspace*{-.5em}
  \caption{Code in language B with a conditional statement}
  \label{fig:exam2}
\end{figure}

\subsection{Interactions between Multilingual Modules}

Let us consider two multilingual programs written in a Java-like language A
and a C-like language B.

The first program in Figure~\ref{fig:exam1} has two parts:
Figure~\ref{fig:exam1}(a) shows a method \texttt{main} in language A,
and Figure~\ref{fig:exam1}(b) shows a function \texttt{f} in language B.
The method \texttt{main} calls the function \texttt{f} with the argument
\texttt{node} whose value is \texttt{null}, which passes the null
value from language A to language B. The function \texttt{f} then
checks whether the value of its parameter \texttt{param} is null
and dereferences it only when it is not null.

The second program has the same method in Figure~\ref{fig:exam2}(a)
and the function \texttt{f} in Figure~\ref{fig:exam2}.
Even though the value of \texttt{f}'s parameter \texttt{param} may be \texttt{null},
\texttt{f} does not check its value and simply dereferences it on line 13.
In addition, \texttt{f} has an extra conditional statement on lines 8--12,
which is irrelevant to \texttt{param}.

\subsection{Previous Approaches}
Now, let us perform a dataflow analysis on these programs to detect
the null dereference bug, that is, whether the null value from
language A can be dereferenced in language B or not.
In the first program, since the parameter of \texttt{f} is
dereferenced only when it is not null, it does not have the bug.
Note that to conclude the absence of the bug correctly,
the analysis should also consider control flows.
On the other hand, in the second program, since \texttt{f} does not
check the value of its parameter, it may have the null dereference bug.

The previous approaches either 1) utilize existing analyzers for
languages A and B to generate their summaries and perform the
target dataflow analysis~\cite{LeeASE20,JN-SAF}, or 2) abstract 
the behaviors of the code written in A and B into a single form and
perform the target analysis~\cite{HybriDroid,PyC}
The problem is that since such existing analyzers are mostly general-purpose,
which may have unnecessary computations that are not necessary for the target analysis,
resulting in performance overhead.
For example, even though the analysis of the conditional statement in Figure~\ref{fig:exam2}
is not relevant to the detection of the null dereference bug on line 13,
the conventional target analysis in the previous approaches computes
the information about the conditional statement during its analysis.
This performance overhead would become critical in multilingual analysis
because the analysis of the interactions between different languages would require
the analysis of immense analysis information in both languages.


%\subsection{Declarative style multilingual program analysis}
\subsection{Our Approach}

By using declarative style analysis, we can solve the problem mentioned above.
The main reason is in its query-based analysis: the target-analysis is
written in terms of \textit{query}, and only related data-facts and rules
are used for evaluating the query, reducing the amount of computation.

Let's see how a dataflow analysis can be implemented in declarative style.
Let's define \datalog{node} to be the program entity that can hold the run-time
value, such as variable, literal, or function parameter.  Ultimately, the
result data-fact we want would be \datalog{flow(a,b)}, which will denote the
fact that there is a data flow from \datalog{node a} to \datalog{node b}. The
rule for this data-fact can be defined in terms of another data-fact named
\datalog{step}:

\begin{lstlisting}[style=myDatalog,xleftmargin=2.5em]
flow(a,b) :- step(a,b)
flow(a,b) :- step(a,c), flow(c,b)
\end{lstlisting}

Simply put, this rule states that \datalog{flow} is defined as transitive
closure of \datalog{step}.  Here, \datalog{step(a,b)} denotes the direct data
flow from \datalog{node a} to \datalog{node b}. Again, the data-fact
\datalog{step} can be calculated by rules using another data-facts, which will
be eventually broken down to basic syntactic data-facts.  Then, given the set
of all syntactic data-facts, all the other possible data-facts, including
\datalog{step} and \datalog{flow}, can be calculated. For example, for the
second program, the following data-facts will be generated,

\begin{lstlisting}[style=myDatalog,xleftmargin=2.5em]
step(null, list) // A -> A
step(list, arg) // A -> B
step(arg, ptr) // B -> B
step(ptr, [dereference of ptr]) // B -> B
\end{lstlisting}

then the declarative language engine can compute the result \datalog{flow(null,
[dereference of ptr])}, and the analyzer concludes that there is a dereference
of null. In process of deriving this conclusion, there was no need to consider
the if-statement.

This time, let's say we are analyzing the first program, which requires
considering the control flow.  One way to implement it would be to bring the
concept of guard. We can define the data-fact \datalog{guard(node, cond)} to
indicate that \datalog{node} is contained in the scope of if statement whose
condition is \datalog{cond}.  For example, in the first program, the
\datalog{ptr} node would be guarded with the condition, \ccode{param \!= NULL},
and this is expressed by the data-fact \datalog{guard(ptr, "param \!= NULL")}.
Once the guard is implemented, then all we have to do is to give additional
condition to the data-fact \datalog{step}, so that \datalog{step(a,b)} does not
hold if \datalog{a} or \datalog{b} is guarded by a proper guard, for example,
it contains comparison with null.

The important thing here is that, unlike previous approaches that considers
every if-statement in order to generate the summary, it is not required to
handle all the if-statements in our approach. We can selectively calculate the
certain data-facts regarding certain control flow, only the target-analysis
does require information about it.

In the following sections, we formalize the general approach for performing
declarative style analysis in multilingual program (Section 3), show the
specific implementation of this approach for JNI programs as form of dataflow
analysis, implemented with CodeQL(Section 4) and show the evaluation result of
this implementation (Section 5).

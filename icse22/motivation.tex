\section{Motivation}

In this section, we visualize the problems of previous approaches for
multilingual program analysis with concrete examples, and show how declarative
style implementation can be helpful for those problems.

\subsection{Example target multilingual program}

Let's consider two multilingual programs, written in (Java-like) language A
and (C-like) language B.
\begin{figure}[t]
  \centering
  \vspace{2mm}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=java,xleftmargin=2.5em]
public void main() { //Language A
  Node node = null;
  B::f(node);
}
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{Language A}
    \label{fig:exam1:langA}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=cpp,firstnumber=5,xleftmargin=2.5em]
void f(Node* param) { //Language B
  if(param != NULL) {
    Node* ptr = param;
    ptr->next = new Node;
  }
}
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{Language B}
    \label{fig:exam1:langB}
  \end{subfigure}
  \vspace*{-.5em}
  \caption{EXAMPLE 1}
  \label{fig:exam1}
\end{figure}
Figure \ref{fig:exam1}.

In the first program, value null from language A is passed to the parameter of
function language B via calling it. Then, in language B, it is checked whether
the parameter has null value or not, and only when it is not null, the
parameter is safely dereferenced.

\begin{figure}[t]
  \centering
  \vspace{2mm}
  \begin{lstlisting}[style=cpp,firstnumber=5,xleftmargin=2.5em]
void f(Node* param) { //Language B
  Node* ptr = param;
  Node* next;
  if(condition()) {
    next = null;
  } else {
    next = new Node;
  }
  ptr->next = next;
}
  \end{lstlisting}
  \vspace*{-.5em}
  \caption{EXAMPLE 2. Language B}
  \label{fig:exam2}
\end{figure}
Figure \ref{fig:exam2}.

In the second program, the code for language A is same as before. The
difference is in code for language B. This time, the code does not check whether
or not the parameter is null. Instead, there is another if-statement, which is
not directly related parameter, but affects value of another variable.

\subsection{Previous approaches for performing analysis on target program}

Let's assume that we want to perform dataflow analysis for these programs.
What we are interested is whether the value null from language A can be
dereferenced in language B or not. In the first program, the parameter is
dereferenced only if it is not null, so there is no such a bug. Note that in
order to correctly conclude that there is no error, the control flow should be
considered. On the other hand, in second program, since we do not check the
value of parameter, it should be reported that null dereference error might
happen.

In previous approaches[2][3], existing analyzers are utilized to generate
summaries. Then the actual target-analysis, the dataflow analysis, is performed
on these summaries. The problem is that since such existing analyzers are
mostly general purpose, unnecessary calculations which are not needed for
target-analysis would happen, resulting in the overhead. For example,
calculating information about \textit{if} statement in the first program, and
generating summary regarding it, would be required. However, calculating the
information about \textit{if} in the second program is not necessary for
calculating the dataflow from null to ptr, yet there is no easy way to "turn
off" such heavy computation for this specific \textit{if} statement.

\subsection{Declarative style multilingual program analysis}

By using declarative style analysis, we can solve the problem mentioned above.
The main reason is in its query-based analysis: the target-analysis is
written in terms of \textit{query}, and only related data-facts and rules
are used for evaluating the query, reducing the amount of computation.

Let's see how a dataflow analysis can be implemented in declarative style.
Let's define \datalog{node} to be the program entity that can hold the run-time
value, such as variable, literal, or function parameter.  Ultimately, the
result data-fact we want would be \datalog{flow(a,b)}, which will denote the
fact that there is a data flow from node a to node b. The rule for this
data-fact can be defined in terms of another data-fact named step:

\begin{lstlisting}[style=myDatalog,xleftmargin=2.5em]
flow(a,b) :- step(a,b)
flow(a,b) :- step(a,c), flow(c,b)
\end{lstlisting}

Simply put, this rule states that flow is defined as transitive closure of
step.  Here, \datalog{step(a,b)} denotes the direct data flow from node a to
node b. Again, the data-fact step can be calculated by rules using another
data-facts, which will be eventually broken down to basic syntactic data-facts.
Then, given the set of all syntactic data-facts, all the other possible
data-facts, including \datalog{flow}, can be calculated. For example, for the second
program, the following data-facts will be generated,

\begin{lstlisting}[style=myDatalog,xleftmargin=2.5em]
step(null, list) // A -> A
step(list, arg) // A -> B
step(arg, ptr) // B -> B
step(ptr, [dereference of ptr]) // B -> B
\end{lstlisting}

then the declarative language engine can compute the result \datalog{flow(null,
[dereference of ptr])}, and the analyzer concludes that there is a dereference
of null. In process of deriving this conclusion, there was no need to consider
the \textit{if} statement.

This time, let's say we are analyzing the first program. It would require to
consider the control flow.  One way to implement it would be to bring the
concept of guard. We can define the data-fact \datalog{guard(node, cond)} which
annotating the node is contained in the block defined by given if statement
whose condition is \datalog{cond}.  For example, in the first program, the
\datalog{ptr} node would be guarded with the condition, "param != null", and
this is expressed by the data-fact guard(ptr, "param != null").  Once the guard
is implemented, then all we have to do is to give additional condition to the
data-fact \datalog{step}, so that \datalog{step(a,b)} does not hold if a or b
is guarded by a proper guard, for example, it contains comparison with null.

The important thing here is that, unlike previous approaches that considers
every if-statement in order to generate the summary, such process is not
required in our approach. We can selectively calculate the certain data-fact
regarding control flow, only if we do require it for performing the
target-analysis.

In the following sections, we formalize the general approach for performing
declarative style analysis in multilingual program (Section 3), show the
specific implementation of this approach for JNI programs as form of dataflow
analysis, implemented with CodeQL(Section 4) and show the evaluation result of
this implementation (Section 5).

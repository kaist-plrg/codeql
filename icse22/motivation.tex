\section{Motivation}
In this section, we show how multilanguage interactions work using a
simple example code, and explain the main challenge that is difficult to handle
by the previous approaches but our declarative-style analysis can handle.

\begin{figure}[t]
  \centering
  \vspace{2mm}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=java,xleftmargin=2.5em]
public void main() {
  Node node = null;
  B::f(node);
}
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{Method in language A calling a function in language B}
    \label{fig:exam1:langA}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[style=cpp,firstnumber=5,xleftmargin=2.5em]
void f(Node* param) {
  if(param != NULL) {
    Node* ptr = param;
    ptr->next = new Node;
  }
}
    \end{lstlisting}
    \vspace*{-.5em}
    \caption{Function in language B receiving null from language A}
    \label{fig:exam1:langB}
  \end{subfigure}
  \vspace*{-.5em}
  \caption{Multilingual code in language A and language B}
  \label{fig:exam1}
\end{figure}

\begin{figure}[t]
  \centering
  \vspace{2mm}
  \begin{lstlisting}[style=cpp,firstnumber=5,xleftmargin=2.5em]
void f(Node* param) {
  Node* ptr = param;
  Node* next;
  if(condition()) {
    next = NULL;
  } else {
    next = new Node;
  }
  ptr->next = next;
}
  \end{lstlisting}
  \vspace*{-.5em}
  \caption{Code in language B with a conditional statement}
  \label{fig:exam2}
\end{figure}

\subsection{Interactions between Multilingual Modules}

Let us consider two multilingual programs written in a Java-like language A
and a C-like language B.

The first program in Figure~\ref{fig:exam1} has two parts:
Figure~\ref{fig:exam1}(a) shows a method \texttt{main} in language A,
and Figure~\ref{fig:exam1}(b) shows a function \texttt{f} in language B.
The method \texttt{main} calls the function \texttt{f} with the argument
\texttt{node} whose value is \texttt{null}, which passes the null
value from language A to language B. The function \texttt{f} then
checks whether the value of its parameter \texttt{param} is null
and dereferences it only when it is not null.

The second program has the same method in Figure~\ref{fig:exam2}(a)
and the function \texttt{f} in Figure~\ref{fig:exam2}.
Even though the value of \texttt{f}'s parameter \texttt{param} may be \texttt{null},
\texttt{f} does not check its value and simply dereferences it on line 13.
In addition, \texttt{f} has an extra conditional statement on lines 8--12,
which is irrelevant to \texttt{param}.

\subsection{Previous Approaches}
Now, let us perform a dataflow analysis on these programs to detect
the null dereference bug, that is, whether the null value from
language A can be dereferenced in language B or not.
In the first program, since the parameter of \texttt{f} is
dereferenced only when it is not null, it does not have the bug.
Note that to conclude the absence of the bug correctly,
the analysis should also consider control flows.
On the other hand, in the second program, since \texttt{f} does not
check the value of its parameter, it may have the null dereference bug.

The previous approaches either 1) utilize existing analyzers for
languages A and B to generate their summaries and perform the
target dataflow analysis~\cite{LeeASE20,JN-SAF}, or 2) abstract 
the behaviors of the code written in A and B into a single form and
perform the target analysis~\cite{hybridroid,cpython}
The problem is that since such existing analyzers are mostly general-purpose,
which may have unnecessary computations that are not necessary for the target analysis,
these approaches may result in performance overhead.
For example, even though the analysis of the conditional statement in Figure~\ref{fig:exam2}
is not relevant to the detection of the null dereference bug on line 13,
the conventional target analysis in the previous approaches computes
the information about the conditional statement during its analysis.
This performance overhead would become critical in multilingual analysis
because the analysis of the interactions between different languages would require
the analysis of immense analysis information in both languages.


%\subsection{Declarative style multilingual program analysis}
\subsection{Our Approach}

Finally, our approach is based on a declarative-style analysis, which
alleviates the performance overhead problem of the previous approaches.
The main benefit of the approach comes from its query-based analysis:
a target analysis is
specified in terms of \textit{queries}, and only relevant datafacts and rules
are used for evaluating queries, reducing the amount of computation.

To illustrate, we first explain how we can perform dataflow analysis with
considering control flow in declarative style for the first program, and then
explain why computation for control flow can be reduced for the second program.

  Let's define \datalog{node} to be the program entity that can hold the run-time
value, such as variable, literal, or function parameter.
  Ultimately, the result data-fact we want would be \datalog{flow(a,b)}, which will denote the
fact that there is a data flow from \datalog{node a} to \datalog{node b}.
  The rule for this data-fact can be defined as transitive closure of data-fact named \datalog{step}:
\begin{lstlisting}[style=myDatalog,xleftmargin=2.5em]
flow(a,b) :- step(a,b)
flow(a,b) :- step(a,c), flow(c,b)
\end{lstlisting}
Here, \datalog{step(a,b)} denotes the direct data
flow from \datalog{node a} to \datalog{node b}, where \datalog{step}
can be either intra-language, or inter-language, so the following data-facts
will be generated.
\begin{lstlisting}[style=myDatalog,xleftmargin=2.5em]
step(null, node) // A -> A
step(node, param) // A -> B
\end{lstlisting}
Since there is a if-statement that check  nullity of the param, the null value
does not flow into the variable \datalog{ptr}, so we don't want the data-fact
\datalog{step(param, ptr)} to be generated.  One way to implement it would be
to bring the concept of guard. We can define the data-fact \datalog{guard(node,
cond)} to indicate that \datalog{node} is contained in the scope of if
statement whose condition is \datalog{cond}. In the first program, the
\datalog{ptr} node would be guarded with the condition, \ccode{param \!= NULL},
and this is expressed by the data-fact \datalog{guard(ptr, "param \!= NULL")}.
Using this data-fact \codeql{guard}, we can give additional condition to the
data-fact \datalog{step}, so that \datalog{step(a,b)} does not hold if
\datalog{node b} is contained in a if-statement block, and is guarded by a
proper condition, for example, it contains comparison with null.

Now, let's look at the second program. Using the same approach, the following
data-facts will be generated,

\begin{lstlisting}[style=myDatalog,xleftmargin=2.5em]
step(null, node) // A -> A
step(node, param) // A -> B
step(param, ptr) // B -> B
step(ptr, [dereference of ptr]) // B -> B
\end{lstlisting}
then the declarative language engine can compute the result \datalog{flow(null,
[dereference of ptr])}, and the analyzer concludes that there is a dereference
of null. The important thing here is that none of the nodes in the trace of
steps above is included in the if-statement block. Therefore, in the process of
detecting this bug, there was no need to consider the unrelevant if-statement.


The point is that unlike previous approaches that considers every if-statement
regardless of whether that if-statement is relevant or not, it is not required
to handle all the if-statements in our approach. We can selectively calculate
the certain data-facts regarding certain control flow, only the target analysis
does require information about it.

In the following sections, we formalize the general approach for performing
declarative style analysis in multilingual program (Section 3), show the
specific implementation of this approach for JNI programs as form of dataflow
analysis, implemented with CodeQL(Section 4) and show the evaluation result of
this implementation (Section 5).

\section{Motivation}

In this section, we visualize the problems of multilingual program analysis
with concrete examples, and show how declrative style implementation can be helpful
for those problems.

\subsection{Example 1: Extending to more complex client-analysis}

Let's consider the dataflow analysis for the following program,
which is written in Java-like language A and C-like language B:

EXAMPLE 1

Language A

public void main() \{

  \quad Node node = null;
 
  \quad B::f(node);

\}

Language B

void f(Node* arg) \{
  
  \quad Node* ptr = arg;

  \quad ptr->next = new Node;

\}

What we are interested is whether the value null from language A
can be dereferenced in language B. One way to express this with IR 
would be the following format: 

main: \{

  \quad node = null;
  
  \quad f(node);

\}

f(arg): \{
  
  \quad ptr = arg;
  
  \quad deref(ptr);

\}

Performing dataflow analysis on this IR would be straight forward, and it can
be concluded that te null can be derefereced.

Now, let's assume that we want to analyze the following different program,
where Language B is changed as follow:

EXAMPLE 2

Language B

void f(Node* arg) \{

  \quad Node* ptr = arg;
  
  \quad if(ptr != NULL) \{

    \quad \quad ptr->next = new Node;

  \quad \}

\}

In this example, since the null-check is performed before dereferencing it,
there should be no alarm in this case. However, if IR itself does not contain
the control-flow structure such as if-statement, then the analyzer might
produce the same IR as before as if there were no null checking logic ar all,
and would result in a false alarm that reports the dereference of null. If one
wants to extend this analyzer to support this kind of analysis, then all
three jobs of extending IR, translating source code into extended IR, and
implementing analysis on extended IR. This can be especially more cubersome
if all of three jobs are very different from others.

\subsection{Example 2: Changing into simpler client-analysis}

This time, let's consider the opposite case, where the developer already built
a analyzer aimed for complex analysis, but a user wants to perform a 
simple client-analysis. For example, consider the following example.

EXAMPLE 3

Language B

void f(Node* arg) \{

  \quad Node* ptr = arg;

  \quad Node* next;

  \quad if(condition()) \{

    \quad \quad next = null;
  
  \quad \}

  \quad else \{
   
    \quad \quad next = new Node;
  
  \quad \}

  \quad ptr->next = next;

\}

and let's assume that the analyzer already handles control flow.
However, what user is interested is to find wheter the variable "ptr"
can be null or not, and while determining that, the control flow need
not be considered. Despite that fact, the analyzer would unnecessarily
calculate the analysis result for the variable next, which is a waste
of time.

\subsection{Declarative style analysis}

By using declarative style analysis, some problems can be mitigated.

First, let's see how a dataflow for multilingual program can be implemented in
declrative style. Ultimately, the result data-fact we want would be flow(a,b),
which will denote the fact that there is a data flow from node a to node b. The
rule for this data-fact can be defined in terms of another data-fact named
step:

flow(a,b):-step(a,b) or ( step(a,c) and flow(c,b) )

Simply put, this rule states that flow is defined as transitive closure of step.
Here, step(a,b) denotes the direct data flow from node a to node b. Again, the
data-fact step can be calculated by rules using another data-facts, which will
be eventually broken down to basic syntactic data-facts. Then, given the set of
all syntatctic data-facts, all possible flow data-facts, including flow, can be
calculated by evaluating engine. For example, the following data-facts will be
generated,

step(null, list) // A -> A

step(list, arg) // A -> B

step(arg, ptr) // B -> B

step(ptr, [dereference of ptr]) // B -> B

then the declarative language engine can compute the result flow(null,
[dereference of ptr]), and the analyzer concludes that there is a dereference
of null.

Now, let's say we are extending this analyzer to consider the control flow.
One way to implement it would be to bring the concept of guard, that is,
annotating the nodes within a certain "if statement block" with the condition
of that if statement.  For example, in EXAMPLE 2, the [dereference of ptr] node
would be guarded with the condition, "ptr != null".  Implementing the guard is
simply defining new rules and data-facts. Once the guard is implemented, then
all we have to do is to shrink the data-fact step, so that step(a,b) does not
hold if a or b is guarded by a proper guard.

This time, let's assume that we apply this extended analysis for EXAMPLE 3.
Note that the the condition for "if statement" does not include the bariable
"ptr" here.  Therefore, the datafact regarding "guard" does not need to be
calculated from the beggining. Depending on the optimization of the evaluation
engine, this guard can be effectively precluded from the data-facts
calculation, which can save some time.  Even without the optimization, the
programmer can manually modify the rules regarding guard, which would be not a
big problem compared to non-declarative implementations.

In the following sections, we formalize the general approach for performing
declartive style analysis in multilingual program (Section 3), show the
specific implementation of this appraoch for JNI programs as form of dataflow
analysis, implemented with CodeQL(Section 4) and show the evaluation result of
this implementation (Section 5).

\section{Motivation}

In this section, we visualize the problems of multilingual programa analysis
with concrete examples, and show how declrative style imeplementation can be helpful.

\subsection{Example 1: Extending to more complex client-analysis}

Let's consider the dataflow analysis for the following program,
which is written in Java-like language A and C-like language B:

EXAMPLE 1

Language A

public void main() \{

  Node node = null;
 
  B::f(node);

\}

Language B

void f(Node* arg) \{
  
  Node* ptr = arg;

  ptr->next = new Node;

\}

What we are interested is whether the value null from language A
can be dereferenced in language B. IR~~~

Now, let's assume that we want to analyze the following different program:

EXAMPLE 2

Language A

public void main() \{

  Node node = null;
 
  B::f(node);

\}

Language B

void f(Node* arg) \{

  Node* ptr = arg;
  
  if(ptr != NULL) \{

    ptr->next = new Node;

  \}

\}

In this example, since the null-check is performed before dereferencing it,
there should be no alarm in this case. However, if IR itself does not contain
the control-flow structure such as if-statement, then the analyzer might
produce the same IR as before as if there were no null checking logic, and
would result in a false alarm that reports the dereference of null. If one
wants to extend this analyzer to support this more complex analysis, then all
three jobs of extending IR, translating source code into extended IR, and
implementing analysis on extended IR. This can be especially more cubersome
if all of three jobs are very different from others.

\subsection{Example 2: Changing into simpler client-analysis}

This time, we can think of the situation where we want to change the client analysis
into a simpler one. For example, consider the following example.

EXAMPLE 3

Language A

public void main() \{

  Node node = null;

  B::f(node);

\}

Language B

void f(Node* arg) \{

  Node* ptr = arg;

  for(int i = 0; i < 10; i++) \{

    object* next = new object();
    
    ptr -> next = next;

    ptr = next;
  
  \}

\}

Let's say we have a complex analyzer that can handle this progrma in a
loop-seneitive[6] manner: it can preciely decide that the derefencing null
wouuld only happen in first iteration, at it would never happen at another
iteration.  In order to get this precise result, this would require some
heavy-weight analysis which woulld keep track of the number of iterations, and
IR should be expressive enough to handle all of these semantics.  However, the
user of analyzer might not want to use such a complex analysis, and simply want
to see if null dereferencing is possible at all. In this point of view,
considering loop is unnecessary and it is enough to express as the original IRs.


~~~

\subsection{Declarative style analysis}

By using declarative style analysis, some problems can be mitigated.

First, let's see how a dataflow for multilingual program can be implemented in
declrative style. Ultimately, the result data-fact we want would be flow(a,b),
which will denote the fact that there is a data flow from node a to node b. The
rule for this data-fact can be defined in terms of another data-fact named
step:

flow(a,b):-step(a,b) or ( step(a,c) and flow(c,b) )

Simply put, this rule states that flow is defined as transitive closure of step.
Here, step(a,b) denotes the direct data flow from node a to node b. Again, the
data-fact step can be calculated by rules using another data-facts, which will
be eventually broken down to basic syntactic data-facts. Then, given the set of
all syntatctic data-facts, all possible flow data-facts, including flow, can be
calculated by evaluating engine. For example, the following data-facts will be
generated,

step(null, list) // A -> A

step(list, arg) // A -> B

step(arg, ptr) // B -> B

step(ptr, [dereference of ptr]) // B -> B

then the declarative language engine can compute the result flow(null,
[dereference of ptr]), and the analyzer concludes that there is a dereference
of null.

Now, let's say we are extending this analyzer to consider the control flow.
One way to implement it would be to bring the concept of guard, that is,
annotating the nodes within a certain "if statement block" with the condition
of that if statement.  For example, in EXAMPLE 2, the [dereference of ptr] node
would be guarded with the condition, "ptr != null".  Implementing the guard is
simply defining new rules and data-facts. Once the guard is implemented, then
all we have to do is to shrink the data-fact step, so that step(a,b) does not
hold if a or b is guarded by a proper guard.

This time, 

In the following sections, we formalize the general approach for performing
declartive style analysis in multilingual program (Section 3), show the
specific implementation of this appraoch for JNI programs as form of dataflow
analysis, implemented with CodeQL(Section 4) and show the evaluation result of
this implementation (Section 5).
